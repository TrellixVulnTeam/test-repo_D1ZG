import { BaseService, BaseServiceOptions } from '@gitbeaker/requester-utils';

declare type CamelizeString<T extends PropertyKey> = T extends string ? string extends T ? string : T extends `${infer F}_${infer R}` ? `${F}${Capitalize<CamelizeString<R>>}` : T : T;
declare type Camelize<T> = {
    [K in keyof T as CamelizeString<K>]: T[K];
};
interface Constructor {
    new (...args: any): any;
}
declare type Mapper<T extends {
    [name: string]: Constructor;
}, P extends keyof T> = {
    [name in P]: InstanceType<T[name]>;
};
interface BundleType<T extends {
    [name: string]: Constructor;
}, P extends keyof T> {
    new (options?: any): Mapper<T, P>;
}

declare type Sudo = {
    sudo?: string | number;
};
declare type ShowExpanded<T extends boolean = boolean> = {
    showExpanded?: T;
};
declare type BaseRequestOptions = Sudo & Record<string, unknown>;
declare type BasePaginationRequestOptions<P extends 'keyset' | 'offset' = 'keyset' | 'offset'> = BaseRequestOptions & {
    pagination?: P;
    perPage?: number;
};
declare type OffsetPaginationRequestOptions = {
    page?: number;
    maxPages?: number;
};
declare type PaginatedRequestOptions<P extends 'keyset' | 'offset' = 'keyset' | 'offset'> = P extends 'keyset' ? BasePaginationRequestOptions<P> : BasePaginationRequestOptions<P> & OffsetPaginationRequestOptions;
interface ExpandedResponse<T = Record<string, unknown>> {
    data: T;
    headers: Record<string, unknown>;
    status: number;
}
interface PaginationResponse<T = Record<string, unknown>[]> {
    data: T;
    paginationInfo: {
        total: number;
        next: number | null;
        current: number;
        previous: number | null;
        perPage: number;
        totalPages: number;
    };
}
declare type CamelizedRecord<C, T> = C extends true ? Camelize<T> : T;

interface EventOptions {
    action?: 'created' | 'updated' | 'closed' | 'reopened' | 'pushed' | 'commented' | 'merged' | 'joined' | 'left' | 'destroyed' | 'expired';
    targetType?: 'issue' | 'milestone' | 'merge_request' | 'note' | 'project' | 'snippet' | 'user';
    before?: string;
    after?: string;
    scope?: string;
    sort?: 'asc' | 'desc';
}
interface EventSchema extends Record<string, unknown> {
    id: number;
    title?: string;
    project_id: number;
    action_name: string;
    target_id: number;
    target_type: string;
    author_id: number;
    target_title: string;
    created_at: string;
    author: Omit<UserSchema, 'created_at'>;
    author_username: string;
}
declare class Events<C extends boolean = false> extends BaseService<C> {
    all({ projectId, ...options }?: {
        projectId?: string | number;
    } & PaginatedRequestOptions & EventOptions): Promise<CamelizedRecord<C, EventSchema>[]>;
}

interface UserSchema extends Record<string, unknown> {
    id: number;
    name: string;
    username: string;
    state: string;
    avatar_url: string;
    web_url: string;
    created_at?: string;
}
interface UserExtendedSchema extends UserSchema {
    bio?: string;
    location?: string;
    public_email: string;
    skype: string;
    linkedin: string;
    twitter: string;
    website_url: string;
    organization?: string;
    last_sign_in_at: string;
    confirmed_at: string;
    last_activity_on: string;
    email: string;
    theme_id: number;
    color_scheme_id: number;
    projects_limit: number;
    current_sign_in_at?: string;
    identities?: string[];
    can_create_group: boolean;
    can_create_project: boolean;
    two_factor_enabled: boolean;
    external: boolean;
    private_profile?: string;
}
interface UserActivitySchema extends Record<string, unknown> {
    username: string;
    last_activity_on: string;
    last_activity_at: string;
}
declare class Users<C extends boolean = false> extends BaseService<C> {
    all(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, UserSchema>[]>;
    activities(options?: Sudo): Promise<CamelizedRecord<C, UserActivitySchema>[]>;
    projects(userId: number, options?: Sudo): Promise<CamelizedRecord<C, ProjectExtendedSchema>[]>;
    block(userId: number, options?: Sudo): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    create(options?: BaseRequestOptions): Promise<CamelizedRecord<C, UserSchema>>;
    current(options?: Sudo): Promise<CamelizedRecord<C, UserSchema>>;
    edit(userId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, UserSchema>>;
    events(userId: number, options?: BaseRequestOptions & EventOptions): Promise<CamelizedRecord<C, EventSchema>[]>;
    search(emailOrUsername: string, options?: Sudo): Promise<CamelizedRecord<C, UserSchema>>;
    show(userId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, UserSchema>>;
    remove(userId: number, options?: Sudo): Promise<void>;
    unblock(userId: number, options?: Sudo): Promise<CamelizedRecord<C, Record<string, unknown>>>;
}

declare type AccessLevel = 0 | 5 | 10 | 20 | 30 | 40 | 50;
interface AccessRequestSchema extends Record<string, unknown> {
    id: number;
    username: string;
    name: string;
    state: string;
    created_at: string;
    requested_at: string;
}
declare class ResourceAccessRequests<C extends boolean = false> extends BaseService<C> {
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    all(resourceId: string | number): Promise<CamelizedRecord<C, AccessRequestSchema>[]>;
    request(resourceId: string | number): Promise<CamelizedRecord<C, AccessRequestSchema>>;
    approve(resourceId: string | number, userId: number, options?: {
        accessLevel?: AccessLevel;
    } & Sudo): Promise<CamelizedRecord<C, AccessRequestSchema>>;
    deny(resourceId: string | number, userId: number): Promise<void>;
}

interface AwardEmojiSchema extends Record<string, unknown> {
    id: number;
    name: string;
    user: UserSchema;
    created_at: string;
    updated_at: string;
    awardable_id: number;
    awardable_type: string;
}
declare class ResourceAwardEmojis<C extends boolean = false> extends BaseService<C> {
    protected resourceType: string;
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    all(projectId: string | number, resourceIId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, AwardEmojiSchema>[]>;
    award(projectId: string | number, resourceIId: number, name: string, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
    remove(projectId: string | number, resourceIId: number, awardId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, resourceIId: number, awardId: number, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
}

declare class ResourceNoteAwardEmojis<C extends boolean = false> extends BaseService<C> {
    protected resourceType: string;
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    all(projectId: string | number, resourceIId: number, noteId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, AwardEmojiSchema>[]>;
    award(projectId: string | number, resourceIId: number, noteId: number, name: string, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
    remove(projectId: string | number, resourceIId: number, noteId: number, awardId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, resourceIId: number, noteId: number, awardId: number, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
}

interface BadgeSchema extends Record<string, unknown> {
    name: string;
    id: number;
    link_url: string;
    image_url: string;
    rendered_link_url: string;
    rendered_image_url: string;
    kind: 'project' | 'group';
}
declare class ResourceBadges<C extends boolean = false> extends BaseService<C> {
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    add(resourceId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, BadgeSchema>>;
    all(resourceId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, BadgeSchema>[]>;
    edit(resourceId: string | number, badgeId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, BadgeSchema>>;
    preview(resourceId: string | number, linkUrl: string, imageUrl: string, options?: Sudo): Promise<CamelizedRecord<C, Omit<BadgeSchema, "name" | "id" | "kind">>>;
    remove(resourceId: string | number, badgeId: number, options?: Sudo): Promise<void>;
    show(resourceId: string | number, badgeId: number, options?: Sudo): Promise<CamelizedRecord<C, BadgeSchema>>;
}

interface CustomAttributeSchema extends Record<string, unknown> {
    key: string;
    value: string;
}
declare class ResourceCustomAttributes<C extends boolean = false> extends BaseService<C> {
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    all(resourceId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, CustomAttributeSchema>[]>;
    set(resourceId: string | number, customAttributeId: number, value: string, options?: Sudo): Promise<CamelizedRecord<C, CustomAttributeSchema>>;
    remove(resourceId: string | number, customAttributeId: number, options?: Sudo): Promise<void>;
    show(resourceId: string | number, customAttributeId: number, options?: Sudo): Promise<CamelizedRecord<C, CustomAttributeSchema>>;
}

declare type DeployTokenScope = 'read_repository' | 'read_registry' | 'write_registry' | 'read_package_registry' | 'write_package_registry';
interface DeployTokenSchema extends Record<string, unknown> {
    id: number;
    name: string;
    username: string;
    expires_at: string;
    scopes?: string[];
}
declare class ResourceDeployTokens<C extends boolean = false> extends BaseService<C> {
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    add(resourceId: string | number, tokenName: string, tokenScopes: DeployTokenScope[], options?: BaseRequestOptions): Promise<CamelizedRecord<C, DeployTokenSchema>>;
    all({ resourceId, projectId, groupId, ...options }?: {
        resourceId?: string | number;
        projectId?: string | number;
        groupId?: string | number;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, DeployTokenSchema>[]>;
    remove(resourceId: string | number, tokenId: number, options?: Sudo): Promise<void>;
}

interface PositionSchema {
    base_sha: string;
    start_sha: string;
    head_sha: string;
    old_path: string;
    new_path: string;
    position_type: string;
    old_line: number;
    new_line: number;
}
interface NotesEntitySchema {
    id: number;
    type?: string;
    body: string;
    attachment?: string;
    author: Omit<UserSchema, 'created_at'>;
    created_at: string;
    updated_at: string;
    system: boolean;
    noteable_id: number;
    noteable_type: string;
    noteable_iid?: number;
    resolvable: boolean;
    position?: PositionSchema;
}
interface DiscussionSchema extends Record<string, unknown> {
    id: string;
    individual_note: boolean;
    notes?: NotesEntitySchema[];
}
declare class ResourceDiscussions<C extends boolean = false> extends BaseService<C> {
    protected resource2Type: string;
    constructor(resourceType: string, resource2Type: string, options: BaseServiceOptions<C>);
    addNote(resourceId: string | number, resource2Id: string | number, discussionId: string | number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    all(resourceId: string | number, resource2Id: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>[]>;
    create(resourceId: string | number, resource2Id: string | number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    editNote(resourceId: string | number, resource2Id: string | number, discussionId: string | number, noteId: number, { body, ...options }?: BaseRequestOptions & {
        body?: string;
    }): Promise<CamelizedRecord<C, DiscussionSchema>>;
    removeNote(resourceId: string | number, resource2Id: string | number, discussionId: string | number, noteId: number, options?: Sudo): Promise<void>;
    show(resourceId: string | number, resource2Id: string | number, discussionId: string | number, options?: Sudo): Promise<CamelizedRecord<C, DiscussionSchema>>;
}

interface CommitAction {
    /** The action to perform */
    action: 'create' | 'delete' | 'move' | 'update';
    /** Full path to the file. Ex. lib/class.rb */
    filePath: string;
    /** Original full path to the file being moved.Ex.lib / class1.rb */
    previousPath?: string;
    /** File content, required for all except delete. Optional for move */
    content?: string;
    /** text or base64. text is default. */
    encoding?: string;
    /** Last known file commit id. Will be only considered in update, move and delete actions. */
    lastCommitId?: string;
}
interface CommitSchema extends Record<string, unknown> {
    id: string;
    short_id: string;
    created_at: Date;
    parent_ids?: string[];
    title: string;
    message: string;
    author_name: string;
    author_email: string;
    authored_date?: Date;
    committer_name?: string;
    committer_email?: string;
    committed_date?: Date;
    web_url: string;
}
interface CommitExtendedSchema extends CommitSchema {
    last_pipeline: {
        id: number;
        ref: string;
        sha: string;
        status: string;
    };
    stats: {
        additions: number;
        deletions: number;
        total: number;
    };
    status: string;
}
interface GPGSignatureSchema extends Record<string, unknown> {
    signature_type: 'PGP';
    verification_status: 'verified' | 'unverified';
    gpg_key_id: number;
    gpg_key_primary_keyid: string;
    gpg_key_user_name: string;
    gpg_key_user_email: string;
    gpg_key_subkey_id?: number;
    commit_source: string;
}
interface X509SignatureSchema extends Record<string, unknown> {
    signature_type: 'X509';
    verification_status: 'verified' | 'unverified';
    x509_certificate: {
        id: number;
        subject: string;
        subject_key_identifier: string;
        email: string;
        serial_number: string;
        certificate_status: string;
        x509_issuer: {
            id: number;
            subject: string;
            subject_key_identifier: string;
            crl_url: string;
        };
    };
    commit_source: string;
}
interface MissingSignatureSchema extends Record<string, unknown> {
    message: string;
}
interface CommentSchema extends Record<string, unknown> {
    note: string;
    line_type: 'new' | 'old';
    path: string;
    line: number;
    author: Omit<UserSchema, 'created_at'>;
}
interface CommitDiffSchema extends Record<string, unknown> {
    diff: string;
    new_path: string;
    old_path: string;
    a_mode?: string;
    b_mode: string;
    new_file: boolean;
    renamed_file: boolean;
    deleted_file: boolean;
}
interface CommitStatusSchema extends Record<string, unknown> {
    status: string;
    created_at: string;
    started_at?: string;
    name: string;
    allow_failure: boolean;
    author: Omit<UserSchema, 'created_at'>;
    description?: string;
    sha: string;
    target_url: string;
    finished_at?: string;
    id: number;
    ref: string;
}
interface CommitReferenceSchema extends Record<string, unknown> {
    type: 'branch' | 'tag' | 'all';
    name: string;
}
declare class Commits<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, CommitSchema>[]>;
    cherryPick(projectId: string | number, sha: string, branch: string, options?: Sudo): Promise<CamelizedRecord<C, CommitSchema>>;
    comments(projectId: string | number, sha: string, options?: Sudo): Promise<CamelizedRecord<C, CommentSchema>[]>;
    create(projectId: string | number, branch: string, message: string, actions?: CommitAction[], options?: BaseRequestOptions): Promise<CamelizedRecord<C, CommitExtendedSchema>>;
    createComment(projectId: string | number, sha: string, note: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, CommentSchema>>;
    diff(projectId: string | number, sha: string, options?: Sudo): Promise<CamelizedRecord<C, CommitDiffSchema>>;
    editStatus(projectId: string | number, sha: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, CommitStatusSchema>>;
    references(projectId: string | number, sha: string, options?: Sudo): Promise<CamelizedRecord<C, CommitReferenceSchema>[]>;
    revert(projectId: string | number, sha: string, options?: Sudo): Promise<CamelizedRecord<C, CommitSchema>>;
    show(projectId: string | number, sha: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, CommitExtendedSchema>>;
    statuses(projectId: string | number, sha: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, CommitStatusSchema>[]>;
    mergeRequests(projectId: string | number, sha: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MergeRequestSchema>>;
    signature(projectId: string | number, sha: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, GPGSignatureSchema> | CamelizedRecord<C, X509SignatureSchema> | CamelizedRecord<C, MissingSignatureSchema>>;
}

interface AcceptMergeRequestOptions {
    mergeCommitMessage?: string;
    squashCommitMessage?: string;
    squash?: boolean;
    shouldRemoveSourceBranch?: boolean;
    mergeWhenPipelineSucceeds?: boolean;
    sha?: string;
}
interface ShowMergeRequestOptions {
    renderHtml?: boolean;
    includeDivergedCommitsCount?: true;
    includeRebaseInProgress?: boolean;
}
interface CreateMergeRequestOptions {
    assigneeId?: number;
    description?: string;
    targetProjectId?: number;
    labels?: string | Array<string>;
    milestoneId?: number;
    removeSourceBranch?: boolean;
    allowCollaboration?: boolean;
    allowMaintainerToPush?: boolean;
    squash?: boolean;
}
interface UpdateMergeRequestOptions {
    targetBranch?: number;
    title?: string;
    assigneeId?: number;
    milestoneId?: number;
    labels?: string | Array<string>;
    description?: string;
    stateEvent?: string;
    removeSourceBranch?: boolean;
    squash?: boolean;
    discussionLocked?: boolean;
    allowCollaboration?: boolean;
    allowMaintainerToPush?: boolean;
}
interface AllMergeRequestsOptions {
    state?: 'opened' | 'closed' | 'locked' | 'merged';
    orderBy?: 'created_at' | 'updated_at';
    sort?: 'asc' | 'desc';
    milestone?: 'None' | string;
    view?: string;
    labels?: string | Array<string>;
    withLabelsDetails?: boolean;
    createdAfter?: string;
    createdBefore?: string;
    updatedBefore?: string;
    updatedAfter?: string;
    scope?: 'created_by_me' | 'assigned_to_me' | 'all';
    authorId?: number;
    asigneeId?: number;
    approverIds?: Array<number>;
    approvedByIds?: Array<number>;
    myReactionEmoji?: string;
    sourceBranch?: string;
    targetBranch?: string;
    in?: string;
    wip?: string;
}
interface ReferenceSchema {
    short: string;
    relative: string;
    full: string;
}
interface TaskCompletionStatusSchema {
    count: number;
    completed_count: number;
}
interface PipelineSchema$1 extends Record<string, unknown> {
    id: number;
    sha: string;
    ref: string;
    status: string;
}
interface TimeStatsSchema$1 extends Record<string, unknown> {
    time_estimate: number;
    total_time_spent: number;
    human_time_estimate: string;
    human_total_time_spent: string;
}
interface RebaseSchema extends Record<string, unknown> {
    rebase_in_progress?: boolean;
    merge_error?: string;
}
interface DiffSchema extends Record<string, unknown> {
    id: number;
    head_commit_sha: string;
    base_commit_sha: string;
    start_commit_sha: string;
    created_at: string;
    merge_request_id: number;
    state: string;
    real_size: string;
    commits?: CommitSchema[];
    diffs?: CommitDiffSchema[];
}
interface MergeRequestSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    project_id: number;
    title: string;
    description: string;
    state: string;
    merged_by: Omit<UserSchema, 'created_at'>;
    merged_at: string;
    closed_by?: string;
    closed_at?: string;
    created_at: string;
    updated_at: string;
    target_branch: string;
    source_branch: string;
    upvotes: number;
    downvotes: number;
    author: Omit<UserSchema, 'created_at'>;
    assignee: Omit<UserSchema, 'created_at'>;
    assignees?: Omit<UserSchema, 'created_at'>[];
    reviewers?: Omit<UserSchema, 'created_at'>[];
    source_project_id: number;
    target_project_id: number;
    labels?: string[];
    work_in_progress: boolean;
    milestone: MilestoneSchema;
    merge_when_pipeline_succeeds: boolean;
    merge_status: string;
    sha: string;
    merge_commit_sha?: string;
    squash_commit_sha?: string;
    user_notes_count: number;
    discussion_locked?: string;
    should_remove_source_branch: boolean;
    force_remove_source_branch: boolean;
    web_url: string;
    references: ReferenceSchema;
    time_stats: TimeStatsSchema$1;
    squash: boolean;
    task_completion_status: TaskCompletionStatusSchema;
    has_conflicts: boolean;
    blocking_discussions_resolved: boolean;
    changes?: CommitDiffSchema[];
}
declare class MergeRequests<C extends boolean = false> extends BaseService<C> {
    accept(projectId: string | number, mergerequestIid: number, options?: AcceptMergeRequestOptions & BaseRequestOptions): Promise<CamelizedRecord<C, MergeRequestSchema>>;
    addSpentTime(projectId: string | number, mergerequestIid: number, duration: string, options?: Sudo): Promise<CamelizedRecord<C, TimeStatsSchema$1>>;
    addTimeEstimate(projectId: string | number, mergerequestIid: number, duration: string, options?: Sudo): Promise<CamelizedRecord<C, TimeStatsSchema$1>>;
    all({ projectId, groupId, ...options }?: {
        projectId?: string | number;
        groupId?: string | number;
    } & AllMergeRequestsOptions & PaginatedRequestOptions): Promise<CamelizedRecord<C, MergeRequestSchema>[]>;
    cancelOnPipelineSucess(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, MergeRequestSchema>>;
    changes(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, MergeRequestSchema>>;
    closesIssues(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, IssueSchema>[]>;
    commits(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, CommitSchema>[]>;
    create(projectId: string | number, sourceBranch: string, targetBranch: string, title: string, options?: CreateMergeRequestOptions & BaseRequestOptions): Promise<CamelizedRecord<C, MergeRequestSchema>>;
    edit(projectId: string | number, mergerequestIid: number, options?: UpdateMergeRequestOptions & BaseRequestOptions): Promise<CamelizedRecord<C, MergeRequestSchema>>;
    participants(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, Omit<UserSchema, "created_at">>[]>;
    pipelines(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, PipelineSchema$1>[]>;
    rebase(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, RebaseSchema>>;
    remove(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<void>;
    resetSpentTime(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, TimeStatsSchema$1>>;
    resetTimeEstimate(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, TimeStatsSchema$1>>;
    show(projectId: string | number, mergerequestIid: number, options?: ShowMergeRequestOptions & BaseRequestOptions): Promise<CamelizedRecord<C, MergeRequestSchema>>;
    subscribe(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, MergeRequestSchema>>;
    timeStats(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, TimeStatsSchema$1>>;
    version(projectId: string | number, mergerequestIid: number, versionId: number, options?: Sudo): Promise<CamelizedRecord<C, DiffSchema>>;
    versions(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, DiffSchema>[]>;
    unsubscribe(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, MergeRequestSchema>>;
}

declare type ProjectOrGroup$2 = {
    projectId?: string | number;
    groupId?: string | number;
};
interface TimeStatsSchema extends Record<string, unknown> {
    human_time_estimate?: string;
    human_total_time_spent?: string;
    time_estimate?: number;
    total_time_spent?: number;
}
interface IssueSchema extends Record<string, unknown> {
    state: string;
    description: string;
    weight?: number;
    health_status?: string;
    author: Omit<UserSchema, 'created_at'>;
    milestone: MilestoneSchema;
    project_id: number;
    assignees?: Omit<UserSchema, 'created_at'>[];
    updated_at: string;
    closed_at?: string;
    closed_by?: string;
    id: number;
    title: string;
    created_at: string;
    moved_to_id?: string;
    iid: number;
    labels?: string[];
    upvotes: number;
    downvotes: number;
    merge_requests_count: number;
    user_notes_count: number;
    due_date: string;
    web_url: string;
    references: {
        short: string;
        relative: string;
        full: string;
    };
    time_stats: TimeStatsSchema;
    has_tasks: boolean;
    task_status: string;
    confidential: boolean;
    discussion_locked: boolean;
    _links: {
        self: string;
        notes: string;
        award_emoji: string;
        project: string;
    };
    task_completion_status: {
        count: number;
        completed_count: number;
    };
    subscribed: boolean;
    epic?: {
        id: number;
        iid: number;
        title: string;
        url: string;
        group_id: number;
    };
}
declare class Issues<C extends boolean = false> extends BaseService<C> {
    addSpentTime(projectId: string | number, issueIid: number, duration: string, options?: Sudo): Promise<CamelizedRecord<C, TimeStatsSchema>>;
    addTimeEstimate(projectId: string | number, issueIid: number, duration: string, options?: Sudo): Promise<CamelizedRecord<C, TimeStatsSchema>>;
    all({ projectId, groupId, ...options }?: ProjectOrGroup$2 & PaginatedRequestOptions): Promise<CamelizedRecord<C, Omit<IssueSchema, "epic">>[]>;
    create(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, IssueSchema>>;
    closedBy(projectId: string | number, issueIid: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MergeRequestSchema>[]>;
    edit(projectId: string | number, issueIid: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, IssueSchema>>;
    link(projectId: string | number, issueIId: number, targetProjectId: string | number, targetIssueIId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    links(projectId: string | number, issueIid: number): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    participants(projectId: string | number, issueIid: number, options?: Sudo): Promise<CamelizedRecord<C, Omit<UserSchema, "created_at">>>;
    relatedMergeRequests(projectId: string | number, issueIid: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MergeRequestSchema>>;
    removeLink(projectId: string | number, issueIid: number, issueLinkId: string | number, options?: BaseRequestOptions): Promise<void>;
    remove(projectId: string | number, issueIid: number, options?: Sudo): Promise<void>;
    resetSpentTime(projectId: string | number, issueIid: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, TimeStatsSchema>>;
    resetTimeEstimate(projectId: string | number, issueIid: number, options?: Sudo): Promise<CamelizedRecord<C, TimeStatsSchema>>;
    show(projectId: string | number, issueIid: number, options?: Sudo): Promise<CamelizedRecord<C, IssueSchema>>;
    subscribe(projectId: string | number, issueIid: number, options?: Sudo): Promise<CamelizedRecord<C, IssueSchema>>;
    timeStats(projectId: string | number, issueIid: number, options?: Sudo): Promise<CamelizedRecord<C, TimeStatsSchema>>;
    unsubscribe(projectId: string | number, issueIid: number, options?: Sudo): Promise<CamelizedRecord<C, IssueSchema>>;
}

interface MilestoneSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    project_id: number;
    title: string;
    description: string;
    due_date?: string;
    start_date: string;
    state: string;
    updated_at: string;
    created_at: string;
    expired: boolean;
    web_url?: string;
}
declare class ResourceMilestones<C extends boolean = false> extends BaseService<C> {
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    all(resourceId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, MilestoneSchema>[]>;
    create(resourceId: string | number, title: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MilestoneSchema>>;
    edit(resourceId: string | number, milestoneId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MilestoneSchema>>;
    issues(resourceId: string | number, milestoneId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueSchema>[]>;
    mergeRequests(resourceId: string | number, milestoneId: number, options?: Sudo): Promise<CamelizedRecord<C, MergeRequestSchema>[]>;
    show(resourceId: string | number, milestoneId: number, options?: Sudo): Promise<CamelizedRecord<C, MilestoneSchema>>;
}

interface LabelSchema extends Record<string, unknown> {
    id: number;
    name: string;
    color: string;
    text_color: string;
    description: string;
    description_html: string;
    open_issues_count: number;
    closed_issues_count: number;
    open_merge_requests_count: number;
    subscribed: boolean;
    priority: number;
    is_project_label: boolean;
}
declare class ResourceLabels<C extends boolean = false> extends BaseService<C> {
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    all(resourceId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, LabelSchema>[]>;
    create(resourceId: string | number, labelName: string, color: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, LabelSchema>>;
    edit(resourceId: string | number, labelId: number | string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, LabelSchema>>;
    remove(resourceId: string | number, labelId: number | string, options?: Sudo & ShowExpanded): Promise<void>;
    subscribe(resourceId: string | number, labelId: number | string, options?: Sudo & ShowExpanded): Promise<CamelizedRecord<C, LabelSchema> | ExpandedResponse<CamelizedRecord<C, LabelSchema>>>;
    unsubscribe(resourceId: string | number, labelId: number | string, options?: Sudo & ShowExpanded): Promise<CamelizedRecord<C, LabelSchema> | ExpandedResponse<CamelizedRecord<C, LabelSchema>>>;
}

interface IssueBoardListSchema extends Record<string, unknown> {
    id: number;
    label: Pick<LabelSchema, 'name' | 'color' | 'description'>;
    position: number;
    max_issue_count: number;
    max_issue_weight: number;
    limit_metric?: string;
}
interface IssueBoardSchema extends Record<string, unknown> {
    id: number;
    name: string;
    milestone: Pick<MilestoneSchema, 'id' | 'title'>;
    lists?: IssueBoardListSchema[];
}
declare class ResourceIssueBoards<C extends boolean = false> extends BaseService<C> {
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    all(resourceId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, IssueBoardSchema>[]>;
    create(resourceId: string | number, name: string, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardSchema>>;
    createList(resourceId: string | number, boardId: number, labelId: number | string, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>>;
    edit(resourceId: string | number, boardId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    editList(resourceId: string | number, boardId: number, listId: number, position: number, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>>;
    lists(resourceId: string | number, boardId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>[]>;
    remove(resourceId: string | number, boardId: number, options?: Sudo): Promise<void>;
    removeList(resourceId: string | number, boardId: number, listId: number, options?: Sudo): Promise<void>;
    show(resourceId: string | number, boardId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardSchema>>;
    showList(resourceId: string | number, boardId: number, listId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>>;
}

interface IncludeInherited {
    includeInherited?: boolean;
}
interface MembersSchema extends Record<string, unknown> {
    id: number;
    username: string;
    name: string;
    state: string;
    avatar_url: string;
    web_url: string;
    expires_at: string;
    access_level: AccessLevel;
    email: string;
    group_saml_identity: {
        extern_uid: string;
        provider: string;
        saml_provider_id: number;
    };
}
declare class ResourceMembers<C extends boolean = false> extends BaseService<C> {
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    add(resourceId: string | number, userId: number, accessLevel: AccessLevel, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MembersSchema>>;
    all(resourceId: string | number, { includeInherited, ...options }?: IncludeInherited & PaginatedRequestOptions): Promise<CamelizedRecord<C, MembersSchema>[]>;
    edit(resourceId: string | number, userId: number, accessLevel: AccessLevel, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MembersSchema>>;
    show(resourceId: string | number, userId: number, { includeInherited, ...options }?: IncludeInherited & Sudo): Promise<CamelizedRecord<C, MembersSchema>>;
    remove(resourceId: string | number, userId: number, options?: Sudo): Promise<void>;
}

interface NoteSchema extends Record<string, unknown> {
    id: number;
    body: string;
    author: UserSchema;
    created_at: string;
    updated_at: string;
    confidential: boolean;
}
declare class ResourceNotes<C extends boolean = false> extends BaseService<C> {
    protected resource2Type: string;
    constructor(resourceType: string, resource2Type: string, options: BaseServiceOptions<C>);
    all(resourceId: string | number, resource2Id: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, NoteSchema>[]>;
    create(resourceId: string | number, resource2Id: string | number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, NoteSchema>>;
    edit(resourceId: string | number, resource2Id: string | number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, NoteSchema>>;
    remove(resourceId: string | number, resource2Id: string | number, noteId: number, options?: Sudo): Promise<void>;
    show(resourceId: string | number, resource2Id: string | number, noteId: number, options?: Sudo): Promise<CamelizedRecord<C, NoteSchema>>;
}

interface ResourceTemplateSchema extends Record<string, unknown> {
    name: string;
    content: string;
}
declare class ResourceTemplates<C extends boolean = false> extends BaseService<C> {
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    all(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ResourceTemplateSchema>[]>;
    show(key: string | number, options?: Sudo): Promise<CamelizedRecord<C, ResourceTemplateSchema>>;
}

interface ResourceVariableSchema extends Record<string, unknown> {
    variable_type: 'env_var' | 'file';
    value: string;
    protected: boolean;
    masked: boolean;
    environment_scope?: string;
    key: string;
}
declare class ResourceVariables<C extends boolean> extends BaseService<C> {
    constructor(resourceType: string, options: BaseServiceOptions<C>);
    all(resourceId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ResourceVariableSchema>[]>;
    create(resourceId: string | number, options?: ResourceVariableSchema): Promise<CamelizedRecord<C, ResourceVariableSchema>>;
    edit(resourceId: string | number, keyId: string, options?: Omit<ResourceVariableSchema, 'key'>): Promise<CamelizedRecord<C, ResourceVariableSchema>>;
    show(resourceId: string | number, keyId: string, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ResourceVariableSchema>>;
    remove(resourceId: string | number, keyId: string, options?: PaginatedRequestOptions): Promise<void>;
}

interface LicenseTemplateSchema extends Record<string, unknown> {
    key: string;
    name: string;
    nickname?: string;
    featured: boolean;
    html_url: string;
    source_url: string;
    description: string;
    conditions?: string[];
    permissions?: string[];
    limitations?: string[];
    content: string;
}
interface LicenseTemplates<C extends boolean = false> extends ResourceTemplates<C> {
    all(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, LicenseTemplateSchema>[]>;
    show(key: string | number, options?: Sudo): Promise<CamelizedRecord<C, LicenseTemplateSchema>>;
}
declare class LicenseTemplates<C extends boolean = false> extends ResourceTemplates<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface ExportStatusSchema extends Record<string, unknown> {
    id: number;
    description: string;
    name: string;
    name_with_namespace: string;
    path: string;
    path_with_namespace: string;
    created_at: string;
    export_status: string;
    _links: {
        api_url: string;
        web_url: string;
    };
}
interface FailedRelationSchema {
    id: number;
    created_at: string;
    exception_class: string;
    exception_message: string;
    source: string;
    relation_name: string;
}
interface ImportStatusSchema extends Record<string, unknown> {
    id: number;
    description: string;
    name: string;
    name_with_namespace: string;
    path: string;
    path_with_namespace: string;
    created_at: string;
    import_status: string;
    correlation_id: string;
    failed_relations?: FailedRelationSchema[];
}
interface UploadMetadata {
    filename?: string;
    contentType?: string;
}
declare class ProjectImportExport<C extends boolean = false> extends BaseService<C> {
    download(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    exportStatus(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, ExportStatusSchema>>;
    import(content: string, path: string, { metadata, ...options }?: {
        metadata?: UploadMetadata;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, ImportStatusSchema>>;
    importStatus(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, ImportStatusSchema>>;
    schedule(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, {
        message: string;
    }>>;
}

interface ProjectSchema extends Record<string, unknown> {
    id: number;
    description?: string;
    default_branch: string;
    ssh_url_to_repo: string;
    http_url_to_repo: string;
    web_url: string;
    readme_url: string;
    tag_list?: string[];
    name: string;
    name_with_namespace: string;
    path: string;
    path_with_namespace: string;
    created_at: string;
    last_activity_at: string;
    forks_count: number;
    avatar_url: string;
    star_count: number;
}
interface NamespaceInfoSchema extends Record<string, unknown> {
    id: number;
    name: string;
    path: string;
    kind: string;
    full_path: string;
    avatar_url: string;
    web_url: string;
}
interface AccessSchema {
    access_level: AccessLevel;
    notification_level: number;
}
interface SharedWithGroupSchema {
    group_id: number;
    group_name: string;
    group_full_path: string;
    group_access_level: number;
}
interface ProjectExtendedSchema extends ProjectSchema {
    visibility: string;
    owner: Pick<UserSchema, 'id' | 'name' | 'created_at'>;
    issues_enabled: boolean;
    open_issues_count: number;
    merge_requests_enabled: boolean;
    jobs_enabled: boolean;
    wiki_enabled: boolean;
    snippets_enabled: boolean;
    can_create_merge_request_in: boolean;
    resolve_outdated_diff_discussions: boolean;
    container_registry_enabled: boolean;
    container_expiration_policy: {
        cadence: string;
        enabled: boolean;
        keep_n?: number;
        older_than?: string;
        name_regex_delete?: string;
        name_regex_keep?: string;
        next_run_at: string;
    };
    creator_id: number;
    namespace: NamespaceInfoSchema;
    import_status: string;
    import_error?: string;
    permissions: {
        project_access: AccessSchema;
        group_access: AccessSchema;
    };
    archived: boolean;
    license_url: string;
    license: Pick<LicenseTemplateSchema, 'key' | 'name' | 'nickname' | 'html_url' | 'source_url'>;
    shared_runners_enabled: boolean;
    runners_token: string;
    ci_default_git_depth: number;
    ci_forward_deployment_enabled: boolean;
    public_jobs: boolean;
    shared_with_groups?: SharedWithGroupSchema[];
    repository_storage: string;
    only_allow_merge_if_pipeline_succeeds: boolean;
    allow_merge_on_skipped_pipeline: boolean;
    restrict_user_defined_variables: boolean;
    only_allow_merge_if_all_discussions_are_resolved: boolean;
    remove_source_branch_after_merge: boolean;
    printing_merge_requests_link_enabled: boolean;
    request_access_enabled: boolean;
    merge_method: string;
    auto_devops_enabled: boolean;
    auto_devops_deploy_strategy: string;
    approvals_before_merge: number;
    mirror: boolean;
    mirror_user_id: number;
    mirror_trigger_builds: boolean;
    only_mirror_protected_branches: boolean;
    mirror_overwrites_diverged_branches: boolean;
    external_authorization_classification_label?: string;
    packages_enabled: boolean;
    service_desk_enabled: boolean;
    service_desk_address?: string;
    autoclose_referenced_issues: boolean;
    suggestion_commit_message?: string;
    marked_for_deletion_at: string;
    marked_for_deletion_on: string;
    compliance_frameworks?: string[];
    statistics: {
        commit_count: number;
        storage_size: number;
        repository_size: number;
        wiki_size: number;
        lfs_objects_size: number;
        job_artifacts_size: number;
        packages_size: number;
        snippets_size: number;
    };
    container_registry_image_prefix: string;
    _links: {
        self: string;
        issues: string;
        merge_requests: string;
        repo_branches: string;
        labels: string;
        events: string;
        members: string;
    };
}
interface ProjectFileUploadSchema extends Record<string, unknown> {
    alt: string;
    url: string;
    full_path: string;
    markdown: string;
}
declare class Projects<C extends boolean = false> extends BaseService<C> {
    all(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ProjectSchema>[]>;
    archive(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, ProjectExtendedSchema>>;
    create({ userId, ...options }: ({
        name: string;
    } | {
        path: string;
    }) & {
        userId?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, ProjectExtendedSchema>>;
    edit(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectExtendedSchema>>;
    fork(projectId: string | number, { forkedFromId, ...options }?: {
        forkedFromId?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, ProjectExtendedSchema>>;
    forks(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectExtendedSchema>[]>;
    languages(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, {
        [name: string]: number;
    }>>;
    mirrorPull(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    remove(projectId: string | number, options?: Sudo): Promise<void>;
    removeFork(projectId: string | number, options?: Sudo): Promise<void>;
    search(projectName: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectSchema>[]>;
    share(projectId: string | number, groupId: string | number, groupAccess: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    show(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectExtendedSchema>>;
    star(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, ProjectExtendedSchema>>;
    transfer(projectId: string | number, namespaceId: string | number): Promise<CamelizedRecord<C, ProjectExtendedSchema>>;
    unarchive(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, ProjectExtendedSchema>>;
    unshare(projectId: string | number, groupId: string | number, options?: Sudo): Promise<void>;
    unstar(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, ProjectExtendedSchema>>;
    upload(projectId: string | number, content: string, { metadata, ...options }?: {
        metadata?: UploadMetadata;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, ProjectFileUploadSchema>>;
}

interface GroupSchema extends Record<string, unknown> {
    id: number;
    name: string;
    path: string;
    full_name: string;
    full_path: string;
    parent_id: number;
    visibility: string;
    avatar_url: string;
    web_url: string;
    description: string;
    share_with_group_lock: boolean;
    require_two_factor_authentication: boolean;
    two_factor_grace_period: number;
    project_creation_level: string;
    auto_devops_enabled: boolean;
    subgroup_creation_level: string;
    emails_disabled: boolean;
    mentions_disabled: boolean;
    lfs_enabled: boolean;
    default_branch_protection: number;
    request_access_enabled: boolean;
    file_template_project_id: number;
    created_at: string;
}
declare type GroupDetailSchema = {
    id: number;
    name: string;
    path: string;
    full_name: string;
    full_path: string;
    parent_id: number;
    visibility: string;
    avatar_url: string;
    web_url: string;
    description: string;
    request_access_enabled: boolean;
    file_template_project_id: number;
    runners_token: string;
    shared_with_groups: {
        group_id: number;
        group_name: string;
        group_full_path: string;
        group_access_level: number;
        expires_at: string;
    }[];
    created_at: string;
};
declare class Groups<C extends boolean = false> extends BaseService<C> {
    all(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, GroupSchema>[]>;
    create(name: string, path: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, GroupSchema>>;
    createLDAPLink(groupId: string | number, cn: string, groupAccess: number, provider: string, options?: Sudo & ShowExpanded): Promise<CamelizedRecord<C, Record<string, unknown>> | ExpandedResponse<CamelizedRecord<C, Record<string, unknown>>>>;
    edit(groupId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    projects(groupId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectSchema>[]>;
    remove(groupId: string | number, options?: Sudo & ShowExpanded): Promise<void>;
    removeLDAPLink(groupId: string | number, cn: string, { provider, ...options }?: Sudo & ShowExpanded & {
        provider?: string;
    }): Promise<void>;
    search(nameOrPath: string, options?: Sudo): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    show(groupId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, GroupDetailSchema>>;
    subgroups(groupId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    syncLDAP(groupId: string | number, options?: Sudo & ShowExpanded): Promise<CamelizedRecord<C, Record<string, unknown>> | ExpandedResponse<CamelizedRecord<C, Record<string, unknown>>>>;
    transferProject(groupId: string | number, projectId: string | number, options?: BaseRequestOptions & ShowExpanded): Promise<CamelizedRecord<C, Record<string, unknown>> | ExpandedResponse<CamelizedRecord<C, Record<string, unknown>>>>;
}

interface GroupAccessRequests<C extends boolean = false> extends ResourceAccessRequests<C> {
    all(groupId: string | number): Promise<CamelizedRecord<C, AccessRequestSchema>[]>;
    request(groupId: string | number): Promise<CamelizedRecord<C, AccessRequestSchema>>;
    approve(groupId: string | number, userId: number, options?: {
        accessLevel?: AccessLevel;
    } & Sudo): Promise<CamelizedRecord<C, AccessRequestSchema>>;
    deny(groupId: string | number, userId: number): Promise<void>;
}
declare class GroupAccessRequests<C extends boolean = false> extends ResourceAccessRequests<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface GroupBadgeSchema extends BadgeSchema {
    kind: 'group';
}
interface GroupBadges<C extends boolean = false> extends ResourceBadges<C> {
    add(groupId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, GroupBadgeSchema>>;
    all(groupId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, GroupBadgeSchema>[]>;
    edit(groupId: string | number, badgeId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, GroupBadgeSchema>>;
    preview(groupId: string | number, linkUrl: string, imageUrl: string, options?: Sudo): Promise<CamelizedRecord<C, Omit<GroupBadgeSchema, 'id' | 'name' | 'kind'>>>;
    remove(groupId: string | number, badgeId: number, options?: Sudo): Promise<void>;
    show(groupId: string | number, badgeId: number, options?: Sudo): Promise<CamelizedRecord<C, GroupBadgeSchema>>;
}
declare class GroupBadges<C extends boolean = false> extends ResourceBadges<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface GroupCustomAttributes<C extends boolean = false> extends ResourceCustomAttributes<C> {
    all(groupId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, CustomAttributeSchema>[]>;
    set(groupId: string | number, customAttributeId: number, value: string, options?: Sudo): Promise<CamelizedRecord<C, CustomAttributeSchema>>;
    remove(groupId: string | number, customAttributeId: number, options?: Sudo): Promise<void>;
    show(groupId: string | number, customAttributeId: number, options?: Sudo): Promise<CamelizedRecord<C, CustomAttributeSchema>>;
}
declare class GroupCustomAttributes<C extends boolean = false> extends ResourceCustomAttributes<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface GroupIssueBoardSchema extends IssueBoardSchema {
    group: Pick<GroupSchema, 'id' | 'name' | 'web_url'>;
}
interface GroupIssueBoards<C extends boolean = false> extends ResourceIssueBoards<C> {
    all(groupId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, IssueBoardSchema>[]>;
    create(groupId: string | number, name: string, options?: Sudo): Promise<CamelizedRecord<C, GroupIssueBoardSchema>>;
    createList(groupId: string | number, boardId: number, labelId: number | string, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>>;
    edit(groupId: string | number, boardId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, GroupIssueBoardSchema>>;
    editList(groupId: string | number, boardId: number, listId: number, position: number, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>>;
    lists(groupId: string | number, boardId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>[]>;
    remove(groupId: string | number, boardId: number, options?: Sudo): Promise<void>;
    removeList(groupId: string | number, boardId: number, listId: number, options?: Sudo): Promise<void>;
    show(groupId: string | number, boardId: number, options?: Sudo): Promise<CamelizedRecord<C, GroupIssueBoardSchema>>;
    showList(groupId: string | number, boardId: number, listId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>>;
}
declare class GroupIssueBoards<C extends boolean = false> extends ResourceIssueBoards<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface GroupMembers<C extends boolean = false> extends ResourceMembers<C> {
    add(groupId: string | number, userId: number, accessLevel: AccessLevel, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MembersSchema>>;
    all(groupId: string | number, options?: IncludeInherited & PaginatedRequestOptions): Promise<CamelizedRecord<C, MembersSchema>[]>;
    edit(groupId: string | number, userId: number, accessLevel: AccessLevel, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MembersSchema>>;
    show(groupId: string | number, userId: number, options?: IncludeInherited & Sudo): Promise<CamelizedRecord<C, MembersSchema>>;
    remove(groupId: string | number, userId: number, options?: Sudo): Promise<void>;
}
declare class GroupMembers<C extends boolean = false> extends ResourceMembers<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface GroupMilestones<C extends boolean = false> extends ResourceMilestones<C> {
    all(groupId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, MilestoneSchema>[]>;
    create(groupId: string | number, title: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MilestoneSchema>>;
    edit(groupId: string | number, milestoneId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MilestoneSchema>>;
    issues(groupId: string | number, milestoneId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueSchema>[]>;
    mergeRequests(groupId: string | number, milestoneId: number, options?: Sudo): Promise<CamelizedRecord<C, MergeRequestSchema>[]>;
    show(groupId: string | number, milestoneId: number, options?: Sudo): Promise<CamelizedRecord<C, MilestoneSchema>>;
}
declare class GroupMilestones<C extends boolean = false> extends ResourceMilestones<C> {
    constructor(options: BaseServiceOptions<C>);
}

declare type PipelineStatus = 'created' | 'waiting_for_resource' | 'preparing' | 'pending' | 'running' | 'failed' | 'success' | 'canceled' | 'skipped' | 'manual' | 'scheduled';
interface PipelineSchema extends Record<string, unknown> {
    id: number;
    status: PipelineStatus;
    ref: string;
    sha: string;
    web_url: string;
    created_at: string;
    updated_at: string;
    user: Pick<UserSchema, 'name' | 'avatar_url'>;
}
interface PipelineExtendedSchema extends PipelineSchema {
    project_id: number;
    before_sha: string;
    tag: boolean;
    yaml_errors?: string;
    user: Pick<UserSchema, 'name' | 'username' | 'id' | 'state' | 'avatar_url' | 'web_url'>;
    started_at?: string;
    finished_at: string;
    committed_at?: string;
    duration?: string;
    coverage?: string;
}
interface PipelineVariableSchema extends Record<string, unknown> {
    key: string;
    variable_type?: string;
    value: string;
}
declare class Pipelines<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, PipelineSchema>[]>;
    create(projectId: string | number, ref: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PipelineSchema>>;
    delete(projectId: string | number, pipelineId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, pipelineId: number, options?: Sudo): Promise<CamelizedRecord<C, PipelineSchema>>;
    retry(projectId: string | number, pipelineId: number, options?: Sudo): Promise<CamelizedRecord<C, PipelineExtendedSchema>>;
    cancel(projectId: string | number, pipelineId: number, options?: Sudo): Promise<CamelizedRecord<C, PipelineExtendedSchema>>;
    allVariables(projectId: string | number, pipelineId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, PipelineVariableSchema>[]>;
}

declare type JobScope = 'created' | 'pending' | 'running' | 'failed' | 'success' | 'canceled' | 'skipped' | 'manual';
interface ArtifactSchema extends Record<string, unknown> {
    file_type: string;
    size: number;
    filename: string;
    file_format?: string;
}
interface JobSchema extends Record<string, unknown> {
    id: number;
    status: string;
    stage: string;
    name: string;
    ref: string;
    tag: boolean;
    coverage?: string;
    allow_failure: boolean;
    created_at: Date;
    started_at?: Date;
    finished_at?: Date;
    duration?: number;
    user: UserSchema;
    commit: CommitSchema;
    pipeline: PipelineSchema;
    web_url: string;
    artifacts: ArtifactSchema[];
    runner: RunnerSchema;
    artifacts_expire_at?: Date;
    tag_list?: string[];
}
interface BridgeSchema extends Record<string, unknown> {
    commit: Pick<CommitSchema, 'id' | 'short_id' | 'author_name' | 'author_email' | 'message' | 'title' | 'created_at'>;
    coverage?: string;
    allow_failure: boolean;
    created_at: string;
    started_at: string;
    finished_at: string;
    duration: number;
    queued_duration: number;
    id: number;
    name: string;
    pipeline: Exclude<PipelineSchema & {
        project_id: number;
    }, 'user'>;
    ref: string;
    stage: string;
    status: string;
    tag: boolean;
    web_url: string;
    user: UserSchema;
    downstream_pipeline: Exclude<PipelineSchema, 'user'>;
}
declare class Jobs<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, JobSchema>[]>;
    cancel(projectId: string | number, jobId: number, options?: Sudo): Promise<CamelizedRecord<C, JobSchema>>;
    downloadSingleArtifactFile(projectId: string | number, jobId: number, artifactPath: string, { stream, ...options }?: {
        stream?: boolean;
    } & BaseRequestOptions): NodeJS.ReadableStream | Promise<CamelizedRecord<C, Record<string, unknown>>>;
    downloadSingleArtifactFileFromRef(projectId: string | number, ref: string, artifactPath: string, jobName: string, { stream, ...options }?: {
        stream?: boolean;
    } & BaseRequestOptions): NodeJS.ReadableStream | Promise<CamelizedRecord<C, Record<string, unknown>>>;
    downloadLatestArtifactFile(projectId: string | number, ref: string, jobName: string, { stream, ...options }?: {
        stream?: boolean;
    } & BaseRequestOptions): NodeJS.ReadableStream | Promise<CamelizedRecord<C, Record<string, unknown>>>;
    downloadTraceFile(projectId: string | number, jobId: number, options?: Sudo): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    erase(projectId: string | number, jobId: number, options?: Sudo): Promise<CamelizedRecord<C, JobSchema>>;
    eraseArtifacts(projectId: string | number, jobId: number, options?: Sudo): Promise<void>;
    keepArtifacts(projectId: string | number, jobId: number, options?: Sudo): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    play(projectId: string | number, jobId: number, options?: Sudo): Promise<CamelizedRecord<C, JobSchema>>;
    retry(projectId: string | number, jobId: number, options?: Sudo): Promise<CamelizedRecord<C, JobSchema>>;
    show(projectId: string | number, jobId: number, options?: Sudo): Promise<CamelizedRecord<C, JobSchema>>;
    showPipelineJobs(projectId: string | number, pipelineId: number, options?: {
        scope?: JobScope;
    } & Sudo): Promise<CamelizedRecord<C, JobSchema>>;
    showPipelineBridges(projectId: string | number, pipelineId: number, options?: {
        scope?: JobScope;
    } & Sudo): Promise<CamelizedRecord<C, BridgeSchema>>;
}

interface RunnerSchema extends Record<string, unknown> {
    id: number;
    description: string;
    ip_address: string;
    active: boolean;
    is_shared: boolean;
    name: string;
    online: boolean;
    status: 'running' | 'success' | 'failed' | 'canceled';
}
interface RunnerExtendedSchema extends RunnerSchema {
    architecture?: string;
    description: string;
    contacted_at: string;
    platform?: string;
    projects?: Pick<ProjectSchema, 'id' | 'name' | 'name_with_namespace' | 'path' | 'path_with_namespace'>;
    revision?: string;
    tag_list?: string[];
    version?: string;
    access_level: string;
    maximum_timeout?: number;
}
declare class Runners<C extends boolean = false> extends BaseService<C> {
    all({ projectId, ...options }?: {
        projectId?: string | number;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, RunnerSchema>[]>;
    allOwned(options?: BaseRequestOptions): Promise<CamelizedRecord<C, RunnerSchema>[]>;
    edit(runnerId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, RunnerExtendedSchema>>;
    enable(projectId: string | number, runnerId: number, options?: Sudo): Promise<CamelizedRecord<C, RunnerSchema>>;
    disable(projectId: string | number, runnerId: number, options?: Sudo): Promise<void>;
    jobs(runnerId: number, options?: Sudo): Promise<CamelizedRecord<C, JobSchema>[]>;
    remove(runnerId: number, options?: Sudo): Promise<void>;
    show(runnerId: number, options?: Sudo): Promise<CamelizedRecord<C, RunnerExtendedSchema>>;
}

declare class GroupRunners<C extends boolean = false> extends BaseService<C> {
    all(groupId: string | number, options?: PaginatedRequestOptions & ShowExpanded): Promise<CamelizedRecord<C, RunnerSchema>[] | CamelizedRecord<C, RunnerSchema>[] | PaginationResponse<CamelizedRecord<C, RunnerSchema>[]>>;
}

interface GroupVariables<C extends boolean = false> extends ResourceVariables<C> {
    all(groupId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ResourceVariableSchema>[]>;
    create(groupId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ResourceVariableSchema>>;
    edit(groupId: string | number, key: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ResourceVariableSchema>>;
    show(groupId: string | number, key: string, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ResourceVariableSchema>>;
    remove(groupId: string | number, key: string, options?: PaginatedRequestOptions): Promise<void>;
}
declare class GroupVariables<C extends boolean = false> extends ResourceVariables<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface GroupLabels<C extends boolean = false> extends ResourceLabels<C> {
    all(groupId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, LabelSchema>[]>;
    create(groupId: string | number, labelName: string, color: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, LabelSchema>>;
    edit(groupId: string | number, labelId: number | string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, LabelSchema>>;
    remove(groupId: string | number, labelId: number | string, options?: Sudo): Promise<void>;
    subscribe(groupId: string | number, labelId: number | string, options?: Sudo): Promise<CamelizedRecord<C, LabelSchema>>;
    unsubscribe(groupId: string | number, labelId: number | string, options?: Sudo): Promise<CamelizedRecord<C, LabelSchema>>;
}
declare class GroupLabels<C extends boolean = false> extends ResourceLabels<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface GroupDeployTokens<C extends boolean = false> extends ResourceDeployTokens<C> {
    add(groupId: string | number, tokenName: string, tokenScopes: DeployTokenScope[], options?: BaseRequestOptions): Promise<CamelizedRecord<C, DeployTokenSchema>>;
    all(options?: {
        groupId?: string | number;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, DeployTokenSchema>[]>;
    remove(groupId: string | number, tokenId: number, options?: Sudo): Promise<void>;
}
declare class GroupDeployTokens<C extends boolean = false> extends ResourceDeployTokens<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface EpicSchema extends Record<string, unknown> {
    id: number;
    iid: number;
    group_id: number;
    parent_id: number;
    title: string;
    description: string;
    state: string;
    confidential: string;
    web_url: string;
    reference: string;
    references: {
        short: string;
        relative: string;
        full: string;
    };
    author: Omit<UserSchema, 'created_at'>;
    start_date?: string;
    start_date_is_fixed: boolean;
    start_date_fixed?: string;
    start_date_from_inherited_source?: string;
    due_date: string;
    due_date_is_fixed: boolean;
    due_date_fixed?: string;
    due_date_from_inherited_source: string;
    created_at: string;
    updated_at: string;
    closed_at: string;
    labels?: string[];
    upvotes: number;
    downvotes: number;
    _links: {
        self: string;
        epic_issues: string;
        group: string;
    };
}
declare class Epics<C extends boolean = false> extends BaseService<C> {
    all(groupId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, EpicSchema>[]>;
    create(groupId: string | number, title: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, EpicSchema>>;
    edit(groupId: string | number, epicId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, EpicSchema>>;
    remove(groupId: string | number, epicId: number, options?: Sudo): Promise<void>;
    show(groupId: string | number, epicId: number, options?: Sudo): Promise<CamelizedRecord<C, EpicSchema>>;
}

interface EpicIssueSchema extends Omit<IssueSchema, 'references' | 'task_completion_status'> {
    epic_issue_id: number;
}
declare class EpicIssues<C extends boolean = false> extends BaseService<C> {
    all(groupId: string | number, epicIId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, EpicIssueSchema>[]>;
    assign(groupId: string | number, epicIId: number, epicIssueId: number, options?: Sudo): Promise<CamelizedRecord<C, EpicIssueSchema>>;
    edit(groupId: string | number, epicIId: number, epicIssueId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, EpicIssueSchema>>;
    remove(groupId: string | number, epicIId: number, epicIssueId: number, options?: Sudo): Promise<void>;
}

interface EpicNoteSchema extends NoteSchema {
    file_name: string;
    expires_at: string;
}
interface EpicNotes<C extends boolean = false> extends ResourceNotes<C> {
    all(groupId: string | number, epicId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, EpicNoteSchema>[]>;
    create(groupId: string | number, epicId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, EpicNoteSchema>>;
    edit(groupId: string | number, epicId: number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, EpicNoteSchema>>;
    remove(groupId: string | number, epicId: number, noteId: number, options?: Sudo): Promise<void>;
    show(groupId: string | number, epicId: number, noteId: number, options?: Sudo): Promise<CamelizedRecord<C, EpicNoteSchema>>;
}
declare class EpicNotes<C extends boolean = false> extends ResourceNotes<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface EpicDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    addNote(groupId: string | number, epicId: number, discussionId: number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    all(groupId: string | number, epicId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>[]>;
    create(groupId: string | number, epicId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    editNote(groupId: string | number, epicId: number, discussionId: number, noteId: number, options: BaseRequestOptions & {
        body: string;
    }): Promise<CamelizedRecord<C, DiscussionSchema>>;
    removeNote(groupId: string | number, epicId: number, discussionId: number, noteId: number, options?: Sudo): Promise<void>;
    show(groupId: string | number, epicId: number, discussionId: number, options?: Sudo): Promise<CamelizedRecord<C, DiscussionSchema>>;
}
declare class EpicDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface UserCustomAttributes<C extends boolean = false> extends ResourceCustomAttributes<C> {
    all(userId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, CustomAttributeSchema>[]>;
    set(userId: string | number, customAttributeId: number, value: string, options?: Sudo): Promise<CamelizedRecord<C, CustomAttributeSchema>>;
    remove(userId: string | number, customAttributeId: number, options?: Sudo): Promise<void>;
    show(userId: string | number, customAttributeId: number, options?: Sudo): Promise<CamelizedRecord<C, CustomAttributeSchema>>;
}
declare class UserCustomAttributes<C extends boolean = false> extends ResourceCustomAttributes<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface UserEmailSchema extends Record<string, unknown> {
    id: number;
    email: string;
    confirmed_at: string;
}
declare class UserEmails<C extends boolean = false> extends BaseService<C> {
    all({ userId, ...options }?: {
        userId?: number;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, UserEmailSchema>[]>;
    add(email: string, { userId, ...options }?: {
        userId?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, UserEmailSchema>>;
    show(emailId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, UserEmailSchema>>;
    remove(emailId: number, { userId, ...options }?: {
        userId?: number;
    } & BaseRequestOptions): Promise<void>;
}

declare type ImpersonationTokenScope = 'api' | 'read_user';
declare type ImpersonationTokenState = 'all' | 'active' | 'inactive';
interface UserImpersonationTokenSchema extends Record<string, unknown> {
    active: boolean;
    user_id: number;
    scopes?: string[];
    revoked: boolean;
    name: string;
    id: number;
    created_at: string;
    impersonation: boolean;
    expires_at: string;
}
declare class UserImpersonationTokens<C extends boolean = false> extends BaseService<C> {
    all(userId: number, options?: {
        state?: ImpersonationTokenState;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, UserImpersonationTokenSchema>[]>;
    add(userId: number, name: string, scopes: ImpersonationTokenScope, expiresAt: string, options?: Sudo): Promise<CamelizedRecord<C, UserImpersonationTokenSchema>>;
    show(userId: number, tokenId: number, options?: Sudo): Promise<CamelizedRecord<C, UserImpersonationTokenSchema>>;
    revoke(userId: number, tokenId: number, options?: Sudo): Promise<void>;
}

interface UserSSHKeySchema extends Record<string, unknown> {
    id: number;
    key: string;
    title: string;
    created_at: string;
}
declare class UserSSHKeys<C extends boolean = false> extends BaseService<C> {
    all({ userId, ...options }?: {
        userId?: number;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, UserSSHKeySchema>[]>;
    create(title: string, key: string, { userId, ...options }?: {
        userId?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, UserSSHKeySchema>>;
    show(keyId: number, { userId, ...options }?: {
        userId?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, UserSSHKeySchema>>;
    remove(keyId: number, { userId, ...options }?: {
        userId?: number;
    } & BaseRequestOptions): Promise<void>;
}

interface UserGPGKeySchema extends Record<string, unknown> {
    id: number;
    key: string;
    created_at: string;
}
declare class UserGPGKeys<C extends boolean = false> extends BaseService<C> {
    all({ userId, ...options }?: {
        userId?: number;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, UserGPGKeySchema>[]>;
    add(key: string, { userId, ...options }?: {
        userId?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, UserGPGKeySchema>>;
    show(keyId: number, { userId, ...options }?: {
        userId?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, UserGPGKeySchema>>;
    remove(keyId: number, { userId, ...options }?: {
        userId?: number;
    } & BaseRequestOptions): Promise<void>;
}

interface BranchSchema extends Record<string, unknown> {
    name: string;
    merged: boolean;
    protected: boolean;
    default: boolean;
    developers_can_push: boolean;
    developers_can_merge: boolean;
    can_push: boolean;
    web_url: string;
    commit: Omit<CommitSchema, 'web_url' | 'created_at'>;
}
declare class Branches<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, BranchSchema>[]>;
    create(projectId: string | number, branchName: string, ref: string, options?: Sudo): Promise<CamelizedRecord<C, BranchSchema>>;
    remove(projectId: string | number, branchName: string, options?: Sudo): Promise<void>;
    show(projectId: string | number, branchName: string, options?: Sudo): Promise<CamelizedRecord<C, BranchSchema>>;
}

interface CommitDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    addNote(projectId: string | number, commitId: number, discussionId: number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    all(projectId: string | number, commitId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>[]>;
    create(projectId: string | number, commitId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    editNote(projectId: string | number, commitId: number, discussionId: number, noteId: number, options: BaseRequestOptions & {
        body: string;
    }): Promise<CamelizedRecord<C, DiscussionSchema>>;
    removeNote(projectId: string | number, commitId: number, discussionId: number, noteId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, commitId: number, discussionId: number, options?: Sudo): Promise<CamelizedRecord<C, DiscussionSchema>>;
}
declare class CommitDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface TagSchema$1 extends Record<string, unknown> {
    name: string;
    path: string;
    location: string;
    revision: string;
    short_revision: string;
    digest: string;
    created_at: string;
    total_size: number;
}
interface RepositorySchema extends Record<string, unknown> {
    id: number;
    name: string;
    path: string;
    project_id: number;
    location: string;
    created_at: string;
    cleanup_policy_started_at: string;
    tags_count?: number;
    tags?: Pick<TagSchema$1, 'name' | 'path' | 'location'>[];
}
declare class ContainerRegistry<C extends boolean = false> extends BaseService<C> {
    projectRepositories(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, Omit<RepositorySchema, "tags" | "tags_count">>[]>;
    groupRepositories(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, Omit<RepositorySchema, "tags" | "tags_count">>[]>;
    showRepository(projectId: string | number, repositoryId: number, options?: Sudo): Promise<CamelizedRecord<C, RepositorySchema>>;
    tags(projectId: string | number, repositoryId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, Pick<TagSchema$1, "name" | "path" | "location">>[]>;
    removeRepository(projectId: string | number, repositoryId: number, options?: Sudo): Promise<void>;
    removeTag(projectId: string | number, repositoryId: number, tagName: string, options?: Sudo): Promise<void>;
    removeTags(projectId: string | number, repositoryId: number, nameRegexDelete: string, options?: Sudo & {
        nameRegexKeep: string;
        keepN: string;
        olderThan: string;
    }): Promise<void>;
    showTag(projectId: string | number, repositoryId: number, tagName: string, options?: Sudo): Promise<CamelizedRecord<C, TagSchema$1>>;
}

interface EnvironmentSchema extends Record<string, unknown> {
    id: number;
    name: string;
    slug?: string;
    external_url?: string;
    project?: ProjectSchema;
    state?: string;
    last_deployment?: DeploymentSchema;
    deployable?: DeployableSchema;
}
declare class Environments<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, Omit<EnvironmentSchema, "last_deployment" | "deployable">>[]>;
    show(projectId: string | number, environmentId: number, options?: Sudo): Promise<CamelizedRecord<C, EnvironmentSchema>>;
    create(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, Omit<EnvironmentSchema, "last_deployment" | "deployable">>>;
    edit(projectId: string | number, environmentId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, Omit<EnvironmentSchema, "last_deployment" | "deployable">>>;
    remove(projectId: string | number, environmentId: number, options?: Sudo): Promise<void>;
    stop(projectId: string | number, environmentId: number, options?: Sudo): Promise<CamelizedRecord<C, Omit<EnvironmentSchema, "last_deployment" | "deployable">>>;
}

declare type DeploymentStatus = 'created' | 'running' | 'success' | 'failed' | 'canceled';
interface DeployableSchema {
    id: number;
    ref: string;
    name: string;
    runner?: RunnerSchema;
    stage?: string;
    started_at?: Date;
    status?: DeploymentStatus;
    tag: boolean;
    commit?: CommitSchema;
    coverage?: string;
    created_at?: Date;
    finished_at?: Date;
    user?: UserSchema;
    pipeline?: PipelineSchema;
}
declare type DeploymentSchema = {
    id: number;
    iid: number;
    ref: string;
    sha: string;
    user: UserSchema;
    created_at: string;
    updated_at: string;
    status: DeploymentStatus;
    deployable: DeployableSchema;
    environment: EnvironmentSchema;
};
declare class Deployments<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, DeploymentSchema>[]>;
    create(projectId: string | number, environment: string, sha: string, ref: string, tag: string, status: DeploymentStatus, options?: Sudo): Promise<CamelizedRecord<C, DeploymentSchema>>;
    edit(projectId: string | number, deploymentId: number, status: DeploymentStatus, options?: Sudo): Promise<CamelizedRecord<C, DeploymentSchema>>;
    show(projectId: string | number, deploymentId: number, options?: Sudo): Promise<CamelizedRecord<C, DeploymentSchema>>;
    mergeRequests(projectId: string | number, deploymentId: number, options?: Sudo): Promise<CamelizedRecord<C, MergeRequestSchema>[]>;
}

interface DeployKey extends Record<string, unknown> {
    id: number;
    title: string;
    key: string;
    can_push?: boolean;
    created_at: string;
}
declare class DeployKeys<C extends boolean = false> extends BaseService<C> {
    add(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, DeployKey>>;
    all({ projectId, ...options }?: {
        projectId?: string | number;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, Omit<DeployKey, "can_push">>[]>;
    edit(projectId: string | number, keyId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DeployKey>>;
    enable(projectId: string | number, keyId: number, options?: Sudo): Promise<CamelizedRecord<C, Omit<DeployKey, "can_push">>>;
    remove(projectId: string | number, keyId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, keyId: number, options?: Sudo): Promise<CamelizedRecord<C, DeployKey>>;
}

interface FreezePeriodSchema extends Record<string, unknown> {
    id: number;
    freeze_start: string;
    freeze_end: string;
    cron_timezone: string;
    created_at: string;
    updated_at: string;
}
declare class FreezePeriods<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, FreezePeriodSchema>[]>;
    show(projectId: string | number, freezePeriodId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, FreezePeriodSchema>>;
    create(projectId: number | string, freezeStart: string, freezeEnd: string, options?: Camelize<Pick<FreezePeriodSchema, 'cron_timezone'>> & BaseRequestOptions): Promise<CamelizedRecord<C, FreezePeriodSchema>>;
    edit(projectId: number | string, freezePeriodId: number, options?: Camelize<Omit<FreezePeriodSchema, 'id' | 'created_at' | 'updated_at'>> & BaseRequestOptions): Promise<CamelizedRecord<C, FreezePeriodSchema>>;
    delete(projectId: number | string, freezePeriodId: number, options?: BaseRequestOptions): Promise<void>;
}

declare type ProjectOrGroup$1 = {
    projectId?: string | number;
    groupId?: string | number;
};
interface StatisticsSchema extends Record<string, unknown> {
    statistics: {
        counts: {
            all: number;
            closed: number;
            opened: number;
        };
    };
}
declare class IssuesStatistics<C extends boolean = false> extends BaseService<C> {
    all({ projectId, groupId, ...options }?: ProjectOrGroup$1 & BaseRequestOptions): Promise<CamelizedRecord<C, StatisticsSchema>>;
}

interface IssueNoteSchema extends NoteSchema {
    attachment?: string;
    system: boolean;
    noteable_id: number;
    noteable_type: string;
    noteable_iid: number;
    resolvable: boolean;
}
interface IssueNotes<C extends boolean = false> extends ResourceNotes<C> {
    all(projectId: string | number, issueIId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, IssueNoteSchema>[]>;
    create(projectId: string | number, issueIId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, IssueNoteSchema>>;
    edit(projectId: string | number, issueIId: number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, IssueNoteSchema>>;
    remove(projectId: string | number, issueIId: number, noteId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, issueIId: number, noteId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueNoteSchema>>;
}
declare class IssueNotes<C extends boolean = false> extends ResourceNotes<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface IssueNoteAwardEmojis<C extends boolean = false> extends ResourceNoteAwardEmojis<C> {
    all(projectId: string | number, issueIId: number, noteId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, AwardEmojiSchema>[]>;
    award(projectId: string | number, issueIId: number, noteId: number, name: string, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
    remove(projectId: string | number, issueIId: number, noteId: number, awardId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, issueIId: number, noteId: number, awardId: number, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
}
declare class IssueNoteAwardEmojis<C extends boolean = false> extends ResourceNoteAwardEmojis<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface IssueDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    addNote(projectId: string | number, issueIId: number, discussionId: number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    all(projectId: string | number, issueIId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>[]>;
    create(projectId: string | number, issueIId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    editNote(projectId: string | number, issueIId: number, discussionId: number, noteId: number, options: BaseRequestOptions & {
        body: string;
    }): Promise<CamelizedRecord<C, DiscussionSchema>>;
    removeNote(projectId: string | number, issueIId: number, discussionId: number, noteId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, issueIId: number, discussionId: number, options?: Sudo): Promise<CamelizedRecord<C, DiscussionSchema>>;
}
declare class IssueDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface IssueAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    all(projectId: string | number, issueIId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, AwardEmojiSchema>[]>;
    award(projectId: string | number, issueIId: number, name: string, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
    remove(projectId: string | number, issueIId: number, awardId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, issueIId: number, awardId: number, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
}
declare class IssueAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface Labels<C extends boolean = false> extends ResourceLabels<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, LabelSchema>[]>;
    create(projectId: string | number, labelName: string, color: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, LabelSchema>>;
    edit(projectId: string | number, labelId: number | string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, LabelSchema>>;
    remove(projectId: string | number, labelId: number | string, options?: Sudo): Promise<void>;
    subscribe(projectId: string | number, labelId: number | string, options?: Sudo): Promise<CamelizedRecord<C, LabelSchema>>;
    unsubscribe(projectId: string | number, labelId: number | string, options?: Sudo): Promise<CamelizedRecord<C, LabelSchema>>;
}
declare class Labels<C extends boolean = false> extends ResourceLabels<C> {
    constructor(options: BaseServiceOptions<C>);
}

declare type ApprovalRulesRequestOptions = {
    userIds?: number[];
    groupIds?: number[];
    protectedBranchIds?: number[];
};
declare class MergeRequestApprovals<C extends boolean = false> extends BaseService<C> {
    addApprovalRule(projectId: string | number, name: string, approvalsRequired: number, { mergerequestIid, ...options }: {
        mergerequestIid?: number;
    } & ApprovalRulesRequestOptions & BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    approvalRules(projectId: string | number, { mergerequestIid, ...options }?: {
        mergerequestIid?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    approvals(projectId: string | number, { mergerequestIid, ...options }?: {
        mergerequestIid?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    approvalState(projectId: string | number, mergerequestIid: number, options?: {
        sha?: string;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    approve(projectId: string | number, mergerequestIid: number, options?: {
        sha?: string;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    approvers(projectId: string | number, approverIds: number[], approverGroupIds: (string | number)[], { mergerequestIid, ...options }?: {
        mergerequestIid?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    editApprovalRule(projectId: string | number, approvalRuleId: number, name: string, approvalsRequired: number, { mergerequestIid, ...options }?: {
        mergerequestIid?: number;
    } & ApprovalRulesRequestOptions & BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    editApprovals(projectId: string | number, { mergerequestIid, ...options }?: {
        mergerequestIid?: number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    removeApprovalRule(projectId: string | number, approvalRuleId: number, { mergerequestIid, ...options }?: {
        mergerequestIid?: number;
    } & BaseRequestOptions): Promise<void>;
    unapprove(projectId: string | number, mergerequestIid: number, options?: Sudo): Promise<CamelizedRecord<C, Record<string, unknown>>>;
}

interface MergeRequestAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    all(projectId: string | number, mergerequestIId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, AwardEmojiSchema>[]>;
    award(projectId: string | number, mergerequestIId: number, name: string, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
    remove(projectId: string | number, mergerequestIId: number, awardId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, mergerequestIId: number, awardId: number, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
}
declare class MergeRequestAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface MergeRequestDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    addNote(projectId: string | number, mergerequestId: string | number, discussionId: number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    all(projectId: string | number, issueId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>[]>;
    create(projectId: string | number, mergerequestId: string | number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    editNote(projectId: string | number, mergerequestId: string | number, discussionId: number, noteId: number, options: BaseRequestOptions & ({
        body: string;
    } | {
        resolved: boolean;
    })): Promise<CamelizedRecord<C, DiscussionSchema>>;
    removeNote(projectId: string | number, issueId: string | number, discussionId: number, noteId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, mergerequestId: string | number, discussionId: number, options?: Sudo): Promise<CamelizedRecord<C, DiscussionSchema>>;
}
declare class MergeRequestDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface MergeRequestNoteSchema extends NoteSchema {
    attachment?: string;
    system: boolean;
    noteable_id: number;
    noteable_type: string;
    noteable_iid: number;
    resolvable: boolean;
}
interface MergeRequestNotes<C extends boolean = false> extends ResourceNotes<C> {
    all(projectId: string | number, mergerequestId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, MergeRequestNoteSchema>[]>;
    create(projectId: string | number, mergerequestId: string | number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MergeRequestNoteSchema>>;
    edit(projectId: string | number, mergerequestId: string | number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MergeRequestNoteSchema>>;
    remove(projectId: string | number, mergerequestId: string | number, noteId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, mergerequestIdepicId: string | number, noteId: number, options?: Sudo): Promise<CamelizedRecord<C, MergeRequestNoteSchema>>;
}
declare class MergeRequestNotes<C extends boolean = false> extends ResourceNotes<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface PackageSchema extends Record<string, unknown> {
    id: number;
    name: string;
    version: string;
    package_type: string;
    created_at: string;
}
interface PackageFileSchema extends Record<string, unknown> {
    id: number;
    package_id: number;
    created_at: string;
    file_name: string;
    size: number;
    file_md5: string;
    file_sha1: string;
    pipelines?: PipelineSchema[];
}
declare class Packages<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, PackageSchema>[]>;
    remove(projectId: string | number, packageId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, packageId: number, options?: Sudo): Promise<CamelizedRecord<C, PackageSchema>>;
    showFiles(projectId: string | number, packageId: number, options?: Sudo): Promise<CamelizedRecord<C, PackageFileSchema>[]>;
}

interface PipelineScheduleSchema extends Record<string, unknown> {
    id: number;
    description: string;
    ref: string;
    cron: string;
    cron_timezone: string;
    next_run_at: string;
    active: boolean;
    created_at: string;
    updated_at: string;
    owner: Pick<UserSchema, 'name' | 'username' | 'id' | 'state' | 'avatar_url' | 'web_url'>;
}
interface PipelineScheduleExtendedSchema extends PipelineScheduleSchema {
    last_pipeline: Pick<PipelineSchema, 'id' | 'sha' | 'ref' | 'status'>;
}
declare class PipelineSchedules<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, PipelineScheduleSchema>[]>;
    create(projectId: string | number, description: string, ref: string, cron: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PipelineScheduleSchema & {
        variables?: PipelineVariableSchema[] | undefined;
    }>>;
    edit(projectId: string | number, scheduleId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PipelineScheduleExtendedSchema>>;
    remove(projectId: string | number, scheduleId: number, options?: Sudo): Promise<CamelizedRecord<C, PipelineScheduleExtendedSchema>>;
    show(projectId: string | number, scheduleId: number, options?: Sudo): Promise<CamelizedRecord<C, PipelineScheduleExtendedSchema>>;
    takeOwnership(projectId: string | number, scheduleId: number, options?: Sudo): Promise<CamelizedRecord<C, PipelineScheduleExtendedSchema>>;
}

declare class PipelineScheduleVariables<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, pipelineScheduleId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, PipelineVariableSchema>[]>;
    create(projectId: string | number, pipelineScheduleId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PipelineVariableSchema>>;
    edit(projectId: string | number, pipelineScheduleId: number, keyId: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PipelineVariableSchema>>;
    show(projectId: string | number, pipelineScheduleId: number, keyId: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PipelineVariableSchema>>;
    remove(projectId: string | number, pipelineScheduleId: number, keyId: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PipelineVariableSchema>>;
}

declare class ProjectAccessRequests<C extends boolean = false> extends ResourceAccessRequests<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface ProjectBadgeSchema extends BadgeSchema {
    kind: 'project';
}
interface ProjectBadges<C extends boolean = false> extends ResourceBadges<C> {
    add(productId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectBadgeSchema>>;
    all(productId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ProjectBadgeSchema>[]>;
    edit(productId: string | number, badgeId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectBadgeSchema>>;
    preview(productId: string | number, linkUrl: string, imageUrl: string, options?: Sudo): Promise<CamelizedRecord<C, Omit<ProjectBadgeSchema, 'id' | 'name' | 'kind'>>>;
    remove(productId: string | number, badgeId: number, options?: Sudo): Promise<void>;
    show(productId: string | number, badgeId: number, options?: Sudo): Promise<CamelizedRecord<C, ProjectBadgeSchema>>;
}
declare class ProjectBadges<C extends boolean = false> extends ResourceBadges<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface ProjectCustomAttributes<C extends boolean = false> extends ResourceCustomAttributes<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, CustomAttributeSchema>[]>;
    set(projectId: string | number, customAttributeId: number, value: string, options?: Sudo): Promise<CamelizedRecord<C, CustomAttributeSchema>>;
    remove(projectId: string | number, customAttributeId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, customAttributeId: number, options?: Sudo): Promise<CamelizedRecord<C, CustomAttributeSchema>>;
}
declare class ProjectCustomAttributes<C extends boolean> extends ResourceCustomAttributes<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface ProjectIssueBoardSchema extends IssueBoardSchema {
    project: Pick<ProjectSchema, 'id' | 'name' | 'name_with_namespace' | 'path' | 'path_with_namespace' | 'http_url_to_repo' | 'web_url'>;
}
interface ProjectIssueBoards<C extends boolean = false> extends ResourceIssueBoards<C> {
    all(groupId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ProjectIssueBoardSchema>[]>;
    create(groupId: string | number, name: string, options?: Sudo): Promise<CamelizedRecord<C, ProjectIssueBoardSchema>>;
    createList(groupId: string | number, boardId: number, labelId: number | string, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>>;
    edit(groupId: string | number, boardId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectIssueBoardSchema>>;
    editList(groupId: string | number, boardId: number, listId: number, position: number, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>>;
    lists(groupId: string | number, boardId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>[]>;
    remove(groupId: string | number, boardId: number, options?: Sudo): Promise<void>;
    removeList(groupId: string | number, boardId: number, listId: number, options?: Sudo): Promise<void>;
    show(groupId: string | number, boardId: number, options?: Sudo): Promise<CamelizedRecord<C, ProjectIssueBoardSchema>>;
    showList(groupId: string | number, boardId: number, listId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueBoardListSchema>>;
}
declare class ProjectIssueBoards<C extends boolean = false> extends ResourceIssueBoards<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface ProjectHookSchema extends Record<string, unknown> {
    id: number;
    url: string;
    project_id: number;
    push_events: boolean;
    push_events_branch_filter: string;
    issues_events: boolean;
    confidential_issues_events: boolean;
    merge_requests_events: boolean;
    tag_push_events: boolean;
    note_events: boolean;
    confidential_note_events: boolean;
    job_events: boolean;
    pipeline_events: boolean;
    wiki_page_events: boolean;
    deployment_events: boolean;
    releases_events: boolean;
    enable_ssl_verification: boolean;
    created_at: string;
}
declare class ProjectHooks<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ProjectHookSchema>[]>;
    show(projectId: string | number, hookId: number, options?: Sudo): Promise<CamelizedRecord<C, ProjectHookSchema>>;
    add(projectId: string | number, url: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectHookSchema>>;
    edit(projectId: string | number, hookId: number, url: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectHookSchema>>;
    remove(projectId: string | number, hookId: number, options?: Sudo): Promise<void>;
}

declare class ProjectMembers<C extends boolean = false> extends ResourceMembers<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface ProjectMilestones<C extends boolean = false> extends ResourceMilestones<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, MilestoneSchema>[]>;
    create(projectId: string | number, title: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MilestoneSchema>>;
    edit(projectId: string | number, milestoneId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, MilestoneSchema>>;
    issues(projectId: string | number, milestoneId: number, options?: Sudo): Promise<CamelizedRecord<C, IssueSchema>[]>;
    mergeRequests(projectId: string | number, milestoneId: number, options?: Sudo): Promise<CamelizedRecord<C, MergeRequestSchema>[]>;
    show(projectId: string | number, milestoneId: number, options?: Sudo): Promise<CamelizedRecord<C, MilestoneSchema>>;
}
declare class ProjectMilestones<C extends boolean = false> extends ResourceMilestones<C> {
    constructor(options: BaseServiceOptions<C>);
}

declare type SnippetVisibility = 'private' | 'public' | 'internal';
interface SnippetSchema extends Record<string, unknown> {
    id: number;
    title: string;
    file_name: string;
    description?: string;
    visibility: string;
    author: Pick<UserSchema, 'name' | 'username' | 'id' | 'state' | 'avatar_url' | 'web_url'>;
    updated_at: string;
    created_at: string;
    project_id?: string | number;
    web_url: string;
    raw_url: string;
}
interface FileSchema {
    path: string;
    raw_url: string;
}
interface SnippetExtendedSchema extends SnippetSchema {
    expires_at?: string;
    ssh_url_to_repo: string;
    http_url_to_repo: string;
    files?: FileSchema[];
}
interface UserAgentDetailSchema extends Record<string, unknown> {
    user_agent: string;
    ip_address: string;
    akismet_submitted: boolean;
}
declare class Snippets<C extends boolean = false> extends BaseService<C> {
    all({ public: p, ...options }?: {
        public?: boolean;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, SnippetSchema>[]>;
    content(snippetId: number, options?: Sudo): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    create(title: string, fileName: string, content: string, visibility: SnippetVisibility, options?: BaseRequestOptions): Promise<CamelizedRecord<C, SnippetExtendedSchema>>;
    edit(snippetId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, SnippetExtendedSchema>>;
    remove(snippetId: number, options?: Sudo): Promise<void>;
    show(snippetId: number, options?: Sudo): Promise<CamelizedRecord<C, SnippetSchema>>;
    userAgentDetails(snippetId: number, options?: Sudo): Promise<CamelizedRecord<C, UserAgentDetailSchema>>;
}

interface ProjectSnippetSchema extends Record<string, unknown> {
    id: number;
    title: string;
    file_name: string;
    description: string;
    author: Pick<UserSchema, 'id' | 'username' | 'name' | 'state' | 'created_at'>;
    updated_at: string;
    created_at: string;
    project_id: number;
    web_url: string;
    raw_url: string;
}
declare class ProjectSnippets<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ProjectSnippetSchema>[]>;
    content(projectId: string | number, snippetId: number, options?: Sudo): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    create(projectId: string | number, title: string, fileName: string, code: string, visibility: SnippetVisibility, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectSnippetSchema>>;
    edit(projectId: string | number, snippetId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProjectSnippetSchema>>;
    remove(projectId: string | number, snippetId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, snippetId: number, options?: Sudo): Promise<CamelizedRecord<C, ProjectSnippetSchema>>;
    userAgentDetails(projectId: string | number, snippetId: number, options?: Sudo): Promise<CamelizedRecord<C, {
        user_agent: string;
        ip_address: string;
        akismet_submitted: boolean;
    }>>;
}

interface SnippetNoteSchema extends NoteSchema {
    file_name: string;
    expires_at: string;
}
interface ProjectSnippetNotes<C extends boolean = false> extends ResourceNotes<C> {
    all(projectId: string | number, snippetId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, SnippetNoteSchema>[]>;
    create(projectId: string | number, snippetId: string | number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, SnippetNoteSchema>>;
    edit(projectId: string | number, snippetId: string | number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, SnippetNoteSchema>>;
    remove(projectId: string | number, snippetId: string | number, noteId: number, options?: Sudo): any;
    show(projectId: string | number, snippetId: string | number, noteId: number, options?: Sudo): Promise<CamelizedRecord<C, SnippetNoteSchema>>;
}
declare class ProjectSnippetNotes<C extends boolean = false> extends ResourceNotes<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface ProjectSnippetDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    addNote(projectId: string | number, snippetId: string | number, discussionId: number, noteId: number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    all(projectId: string | number, issueId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>[]>;
    create(projectId: string | number, snippetId: string | number, body: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, DiscussionSchema>>;
    editNote(projectId: string | number, snippetId: string | number, discussionId: number, noteId: number, options: BaseRequestOptions & {
        body: string;
    }): Promise<CamelizedRecord<C, DiscussionSchema>>;
    removeNote(projectId: string | number, snippetId: string | number, discussionId: number, noteId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, snippetId: string | number, discussionId: number, options?: Sudo): Promise<CamelizedRecord<C, DiscussionSchema>>;
}
declare class ProjectSnippetDiscussions<C extends boolean = false> extends ResourceDiscussions<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface ProjectSnippetAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    all(projectId: string | number, snippetIId: number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, AwardEmojiSchema>[]>;
    award(projectId: string | number, snippetIId: number, name: string, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
    remove(projectId: string | number, snippetIId: number, awardId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, snippetIId: number, awardId: number, options?: Sudo): Promise<CamelizedRecord<C, AwardEmojiSchema>>;
}
declare class ProjectSnippetAwardEmojis<C extends boolean = false> extends ResourceAwardEmojis<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface ProtectedBranchAccessLevelSchema {
    access_level: 0 | 30 | 40 | 60;
    access_level_description: string;
    user_id?: number;
    group_id?: number;
}
interface ProtectedBranchSchema extends Record<string, unknown> {
    id: number;
    name: string;
    push_access_levels?: ProtectedBranchAccessLevelSchema[];
    merge_access_levels?: ProtectedBranchAccessLevelSchema[];
    allow_force_push: boolean;
    code_owner_approval_required: boolean;
}
declare class ProtectedBranches<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: {
        search?: string;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, ProtectedBranchSchema>[]>;
    protect(projectId: string | number, branchName: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProtectedBranchSchema>>;
    show(projectId: string | number, branchName: string, options?: Sudo): Promise<CamelizedRecord<C, ProtectedBranchSchema>>;
    unprotect(projectId: string | number, branchName: string, options?: Sudo): Promise<void>;
}

interface ProtectedTagAccessLevelSchema {
    access_level: 0 | 30 | 40 | 60;
    access_level_description: string;
}
interface ProtectedTagSchema extends Record<string, unknown> {
    name: string;
    create_access_levels?: ProtectedTagAccessLevelSchema[];
}
declare class ProtectedTags<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ProtectedTagSchema>[]>;
    protect(projectId: string | number, tagName: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ProtectedTagSchema>>;
    show(projectId: string | number, tagName: string, options?: Sudo): Promise<CamelizedRecord<C, ProtectedTagSchema>>;
    unprotect(projectId: string | number, tagName: string, options?: Sudo): Promise<void>;
}

interface ProjectVariables<C extends boolean = false> extends ResourceVariables<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ResourceVariableSchema>[]>;
    create(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ResourceVariableSchema>>;
    edit(projectId: string | number, keyId: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ResourceVariableSchema>>;
    show(projectId: string | number, keyId: string, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ResourceVariableSchema>>;
    remove(projectId: string | number, keyId: string, options?: PaginatedRequestOptions): Promise<void>;
}
declare class ProjectVariables<C extends boolean = false> extends ResourceVariables<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface ProjectDeployTokens<C extends boolean = false> extends ResourceDeployTokens<C> {
    add(projectId: string | number, tokenName: string, tokenScopes: DeployTokenScope[], options?: BaseRequestOptions): Promise<CamelizedRecord<C, DeployTokenSchema>>;
    all(options?: {
        projectId?: string | number;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, DeployTokenSchema>[]>;
    remove(projectId: string | number, tokenId: number, options?: Sudo): Promise<void>;
}
declare class ProjectDeployTokens<C extends boolean = false> extends ResourceDeployTokens<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface PushRulesSchema extends Record<string, unknown> {
    id: number;
    project_id: number;
    commit_message_regex: string;
    commit_message_negative_regex: string;
    branch_name_regex: string;
    deny_delete_tag: boolean;
    created_at: string;
    member_check: boolean;
    prevent_secrets: boolean;
    author_email_regex: string;
    file_name_regex: string;
    max_file_size: number;
    commit_committer_check?: boolean;
    reject_unsigned_commits?: boolean;
}
declare class PushRules<C extends boolean = false> extends BaseService<C> {
    create(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PushRulesSchema>>;
    edit(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PushRulesSchema>>;
    remove(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, PushRulesSchema>>;
    show(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, PushRulesSchema>>;
}

interface EvidenceSchema {
    sha: string;
    filepath: string;
    collected_at: string;
}
interface SourceSchema {
    format: string;
    url: string;
}
interface LinkSchema$1 {
    id: number;
    name: string;
    url: string;
    external: boolean;
    link_type: string;
}
interface ReleaseSchema extends Record<string, unknown> {
    tag_name: string;
    description: string;
    name: string;
    description_html: string;
    created_at: string;
    released_at: string;
    user: Pick<UserSchema, 'name' | 'username' | 'id' | 'state' | 'avatar_url' | 'web_url'>;
    commit: CommitSchema;
    milestones?: MilestoneSchema[];
    commit_path: string;
    tag_path: string;
    assets: {
        count: number;
        sources?: SourceSchema[];
        links?: LinkSchema$1[];
        evidence_file_path: string;
    };
    evidences?: EvidenceSchema[];
}
declare class Releases<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ReleaseSchema>[]>;
    create(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ReleaseSchema>>;
    edit(projectId: string | number, tagName: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ReleaseSchema>>;
    remove(projectId: string | number, tagName: string, options?: Sudo): Promise<void>;
    show(projectId: string | number, tagName: string, options?: Sudo): Promise<CamelizedRecord<C, ReleaseSchema>>;
}

interface ReleaseLinkSchema extends Record<string, unknown> {
    id: number;
    name: string;
    url: string;
    external: boolean;
    link_type: string;
}
declare class ReleaseLinks<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, tagName: string, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ReleaseLinkSchema>[]>;
    create(projectId: string | number, tagName: string, name: string, url: string, options?: Sudo & {
        filePath?: string;
        linkType?: string;
    }): Promise<CamelizedRecord<C, ReleaseLinkSchema>>;
    edit(projectId: string | number, tagName: string, linkId: number, options?: Sudo & {
        name?: string;
        url?: string;
        filePath?: string;
        linkType?: string;
    }): Promise<CamelizedRecord<C, ReleaseLinkSchema>>;
    remove(projectId: string | number, tagName: string, linkId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, tagName: string, linkId: number, options?: Sudo): Promise<CamelizedRecord<C, ReleaseLinkSchema>>;
}

declare type ArchiveType = 'tar.gz' | 'tar.bz2' | 'tbz' | 'tbz2' | 'tb2' | 'bz2' | 'tar' | 'zip';
interface RepositoryCompareSchema extends Record<string, unknown> {
    commit: Pick<CommitSchema, 'id' | 'short_id' | 'title' | 'author_name' | 'author_email' | 'created_at'>;
    commits?: Pick<CommitSchema, 'id' | 'short_id' | 'title' | 'author_name' | 'author_email' | 'created_at'>[];
    diffs?: CommitDiffSchema[];
    compare_timeout: boolean;
    compare_same_ref: boolean;
}
interface RepositoryContributorSchema extends Record<string, unknown> {
    name: string;
    email: string;
    commits: number;
    additions: number;
    deletions: number;
}
interface RepositoryTreeSchema extends Record<string, unknown> {
    id: string;
    name: string;
    type: string;
    path: string;
    mode: string;
}
declare class Repositories<C extends boolean = false> extends BaseService<C> {
    compare(projectId: string | number, from: string, to: string, options?: Sudo): Promise<CamelizedRecord<C, RepositoryCompareSchema>>;
    contributors(projectId: string | number, options?: Sudo): Promise<CamelizedRecord<C, RepositoryContributorSchema>[]>;
    mergeBase(projectId: string | number, refs: string[], options?: Sudo): Promise<CamelizedRecord<C, CommitSchema>>;
    showArchive(projectId: string | number, { fileType, ...options }?: {
        fileType?: ArchiveType;
    } & Sudo): Promise<void>;
    showBlob(projectId: string | number, sha: string, options?: Sudo): Promise<Blob>;
    showBlobRaw(projectId: string | number, sha: string, options?: Sudo): Promise<Blob>;
    tree(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, RepositoryTreeSchema>[]>;
}

interface RepositoryFileExtendedSchema extends Record<string, unknown> {
    file_name: string;
    file_path: string;
    size: number;
    encoding: string;
    content: string;
    content_sha256: string;
    ref: string;
    blob_id: string;
    commit_id: string;
    last_commit_id: string;
}
interface RepositoryFileBlameSchema extends Record<string, unknown> {
    commit: CommitSchema;
    lines?: string[];
}
interface RepositoryFileSchema extends Record<string, unknown> {
    file_path: string;
    branch: string;
}
declare class RepositoryFiles<C extends boolean = false> extends BaseService<C> {
    create(projectId: string | number, filePath: string, branch: string, content: string, commitMessage: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, RepositoryFileSchema>>;
    edit(projectId: string | number, filePath: string, branch: string, content: string, commitMessage: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, RepositoryFileSchema>>;
    remove(projectId: string | number, filePath: string, branch: string, commitMessage: string, options?: BaseRequestOptions): Promise<void>;
    show(projectId: string | number, filePath: string, ref: string, options?: Sudo): Promise<CamelizedRecord<C, RepositoryFileExtendedSchema>>;
    showBlame(projectId: string | number, filePath: string, options?: Sudo): Promise<CamelizedRecord<C, RepositoryFileBlameSchema>[]>;
    showRaw(projectId: string | number, filePath: string, ref: string, options?: Sudo): Promise<Blob>;
}

declare type SupportedService = 'asana' | 'assembla' | 'bamboo' | 'bugzilla' | 'buildkite' | 'campfire' | 'custom-issue-tracker' | 'drone-ci' | 'emails-on-push' | 'external-wiki' | 'flowdock' | 'hangouts_chat' | 'hipchat' | 'irker' | 'jira' | 'kubernetes' | 'slack-slash-commands' | 'slack' | 'packagist' | 'pipelines-email' | 'pivotaltracker' | 'prometheus' | 'pushover' | 'redmine' | 'microsoft-teams' | 'mattermost' | 'mattermost-slash-commands' | 'teamcity' | 'jenkins' | 'jenkins-deprecated' | 'mock-ci' | 'youtrack';
interface ServiceSchema extends Record<string, unknown> {
    id: number;
    title: string;
    slug: string;
    created_at: string;
    updated_at: string;
    active: boolean;
    commit_events: boolean;
    push_events: boolean;
    issues_events: boolean;
    confidential_issues_events: boolean;
    merge_requests_events: boolean;
    tag_push_events: boolean;
    note_events: boolean;
    confidential_note_events: boolean;
    pipeline_events: boolean;
    wiki_page_events: boolean;
    job_events: boolean;
    comment_on_event_enabled: boolean;
}
declare class Services<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, ServiceSchema>[]>;
    edit(projectId: string | number, serviceName: SupportedService, options?: BaseRequestOptions): Promise<CamelizedRecord<C, ServiceSchema>>;
    remove(projectId: string | number, serviceName: SupportedService, options?: Sudo): Promise<void>;
    show(projectId: string | number, serviceName: SupportedService, options?: Sudo): Promise<CamelizedRecord<C, ServiceSchema>>;
}

interface TagSchema extends Record<string, unknown> {
    commit: CommitSchema;
    release: Pick<ReleaseSchema, 'tag_name' | 'description'>;
    name: string;
    target: string;
    message?: string;
    protected: boolean;
}
declare class Tags<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, TagSchema>[]>;
    create(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, TagSchema>>;
    remove(projectId: string | number, tagName: string, options?: Sudo): Promise<void>;
    show(projectId: string | number, tagName: string, options?: Sudo): Promise<CamelizedRecord<C, TagSchema>>;
}

interface TodoSchema extends Record<string, unknown> {
    id: number;
    project: Pick<ProjectSchema, 'id' | 'name' | 'name_with_namespace' | 'path' | 'path_with_namespace'>;
    author: Pick<UserSchema, 'name' | 'username' | 'id' | 'state' | 'avatar_url' | 'web_url'>;
    action_name: string;
    target_type: string;
    target: {
        id: number;
        iid: number;
        project_id: number;
        title: string;
        description: string;
        state: string;
        created_at: string;
        updated_at: string;
        target_branch: string;
        source_branch: string;
        upvotes: number;
        downvotes: number;
        author: Pick<UserSchema, 'name' | 'username' | 'id' | 'state' | 'avatar_url' | 'web_url'>;
        assignee: Pick<UserSchema, 'name' | 'username' | 'id' | 'state' | 'avatar_url' | 'web_url'>;
        source_project_id: number;
        target_project_id: number;
        labels?: string[];
        work_in_progress: boolean;
        milestone: Omit<MilestoneSchema, 'start_date' | 'expired' | 'web_url'>;
        merge_when_pipeline_succeeds: boolean;
        merge_status: string;
        user_notes_count: number;
    };
    target_url: string;
    body: string;
    state: string;
    created_at: string;
    updated_at: string;
}
declare class Todos<C extends boolean = false> extends BaseService<C> {
    all(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, TodoSchema>[]>;
    create(projectId: string | number, resourceId: number, resourceName: 'mergerequest' | 'issue', options?: Sudo): Promise<CamelizedRecord<C, TodoSchema>>;
    done({ todoId, ...options }?: {
        todoId?: number;
    } & Sudo): Promise<void> | Promise<CamelizedRecord<C, TodoSchema>>;
}

interface PipelineTriggerSchema extends Record<string, unknown> {
    id: number;
    description: string;
    created_at: string;
    last_used?: string;
    token: string;
    updated_at: string;
    owner: Pick<UserSchema, 'id' | 'name' | 'created_at'>;
}
declare class Triggers<C extends boolean = false> extends BaseService<C> {
    add(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PipelineTriggerSchema>>;
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, PipelineTriggerSchema>[]>;
    edit(projectId: string | number, triggerId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PipelineTriggerSchema>>;
    pipeline(projectId: string | number, ref: string, token: string, { variables }?: {
        variables?: Record<string, string>;
    }): Promise<CamelizedRecord<C, Record<string, unknown>>>;
    remove(projectId: string | number, triggerId: number, options?: Sudo): Promise<void>;
    show(projectId: string | number, triggerId: number, options?: Sudo): Promise<CamelizedRecord<C, PipelineTriggerSchema>>;
}

interface IdentifierSchema {
    external_type: string;
    external_id: string;
    name: string;
    url: string;
}
interface LinkSchema {
    url: string;
}
interface ItemSchema {
    type: string;
    href: string;
}
interface VulnerabilityFindingSchema extends Record<string, unknown> {
    id: number;
    report_type: string;
    name: string;
    severity: string;
    confidence: string;
    scanner: {
        external_id: string;
        name: string;
    };
    identifiers?: IdentifierSchema[];
    project_fingerprint: string;
    uuid: string;
    create_vulnerability_feedback_issue_path: string;
    create_vulnerability_feedback_merge_request_path: string;
    create_vulnerability_feedback_dismissal_path: string;
    project: {
        id: number;
        name: string;
        full_path: string;
        full_name: string;
    };
    dismissal_feedback?: string;
    issue_feedback?: string;
    merge_request_feedback?: string;
    description: string;
    links?: LinkSchema[];
    location: {
        file: string;
        dependency: {
            package: {
                name: string;
            };
            version: string;
        };
    };
    details: {
        [custom_field: string]: {
            name: string;
            type: string;
            items?: ItemSchema[];
        };
    };
    solution: string;
    blob_path: string;
}
declare class VulnerabilityFindings<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: {
        reportType?: string[];
        scope?: string;
        severity?: string[];
        confidence?: string[];
        pipelineId?: string | number;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, VulnerabilityFindingSchema>[]>;
}

interface SettingsSchema extends Record<string, unknown> {
    default_projects_limit: number;
    signup_enabled: boolean;
    id: number;
    default_branch_protection: number;
    restricted_visibility_levels?: string[];
    password_authentication_enabled_for_web: boolean;
    after_sign_out_path?: string;
    max_attachment_size: number;
    max_import_size: number;
    user_oauth_applications: boolean;
    updated_at: string;
    session_expire_delay: number;
    home_page_url?: string;
    default_snippet_visibility: string;
    outbound_local_requests_whitelist?: string[];
    domain_allowlist?: string[];
    domain_denylist_enabled: boolean;
    domain_denylist?: string[];
    created_at: string;
    default_ci_config_path?: string;
    default_project_visibility: string;
    default_group_visibility: string;
    gravatar_enabled: boolean;
    sign_in_text?: string;
    container_expiration_policies_enable_historic_entries: boolean;
    container_registry_token_expire_delay: number;
    repository_storages_weighted: {
        [name: string]: number;
    };
    plantuml_enabled: boolean;
    plantuml_url?: string;
    kroki_enabled: boolean;
    kroki_url?: string;
    terminal_max_session_time: number;
    polling_interval_multiplier: number;
    rsa_key_restriction: number;
    dsa_key_restriction: number;
    ecdsa_key_restriction: number;
    ed25519_key_restriction: number;
    first_day_of_week: number;
    enforce_terms: boolean;
    terms: string;
    performance_bar_allowed_group_id: number;
    user_show_add_ssh_key_message: boolean;
    local_markdown_version: number;
    allow_local_requests_from_hooks_and_services: boolean;
    allow_local_requests_from_web_hooks_and_services: boolean;
    allow_local_requests_from_system_hooks: boolean;
    asset_proxy_enabled: boolean;
    asset_proxy_url: string;
    asset_proxy_whitelist?: string[];
    asset_proxy_allowlist?: string[];
    npm_package_requests_forwarding: boolean;
    snippet_size_limit: number;
    issues_create_limit: number;
    raw_blob_request_limit: number;
    wiki_page_max_content_bytes: number;
    require_admin_approval_after_user_signup: boolean;
    personal_access_token_prefix: string;
    rate_limiting_response_text?: string;
    keep_latest_artifact: boolean;
}
declare class ApplicationSettings<C extends boolean = false> extends BaseService<C> {
    all(options?: Sudo): Promise<CamelizedRecord<C, SettingsSchema>>;
    edit(options?: BaseRequestOptions): Promise<CamelizedRecord<C, SettingsSchema>>;
}

interface BroadcastMessageSchema extends Record<string, unknown> {
    message: string;
    starts_at: string;
    ends_at: string;
    color: string;
    font: string;
    id: number;
    active: boolean;
    target_path: string;
    broadcast_type: string;
    dismissable: boolean;
}
declare class BroadcastMessages<C extends boolean = false> extends BaseService<C> {
    all(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, BroadcastMessageSchema>[]>;
    create(options?: Camelize<Omit<BroadcastMessageSchema, 'id'>> & Sudo): Promise<CamelizedRecord<C, BroadcastMessageSchema>>;
    edit(broadcastMessageId: number, options?: Camelize<Omit<BroadcastMessageSchema, 'id'>> & Sudo): Promise<CamelizedRecord<C, BroadcastMessageSchema>>;
    remove(broadcastMessageId: number, options?: Sudo): Promise<void>;
    show(broadcastMessageId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, BroadcastMessageSchema>>;
}

interface ScopeSchema {
    id: number;
    environment_scope: string;
}
interface StrategySchema {
    id: number;
    name: string;
    parameters: {
        user_ids: string;
    };
    scopes?: ScopeSchema[];
}
interface FeatureFlagSchema extends Record<string, unknown> {
    name: string;
    description: string;
    active: boolean;
    version: string;
    created_at: string;
    updated_at: string;
    scopes?: string[];
    strategies?: StrategySchema[];
}
declare class FeatureFlags<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: {
        scopes?: 'enabled' | 'disabled';
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, FeatureFlagSchema>[]>;
    create(projectId: string | number, flagName: string, version: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, FeatureFlagSchema>>;
    edit(projectId: string | number, flagName: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, FeatureFlagSchema>>;
    remove(projectId: string | number, flagName: string, options?: Sudo): Promise<void>;
    show(projectId: string | number, flagName: string, options?: Sudo): Promise<CamelizedRecord<C, FeatureFlagSchema>>;
}

interface GeoNodeSchema extends Record<string, unknown> {
    id: number;
    name: string;
    url: string;
    internal_url: string;
    primary: boolean;
    enabled: boolean;
    current: boolean;
    files_max_capacity: number;
    repos_max_capacity: number;
    verification_max_capacity: number;
    selective_sync_type: string;
    selective_sync_shards?: string[];
    selective_sync_namespace_ids?: number[];
    minimum_reverification_interval: number;
    container_repositories_max_capacity: number;
    sync_object_storage: boolean;
    clone_protocol: string;
    web_edit_url: string;
    web_geo_projects_url: string;
    _links: {
        self: string;
        status: string;
        repair: string;
    };
}
interface GeoNodeFailureSchema extends Record<string, unknown> {
    project_id: number;
    last_repository_synced_at: string;
    last_repository_successful_sync_at: string;
    last_wiki_synced_at: string;
    last_wiki_successful_sync_at: string;
    repository_retry_count?: number;
    wiki_retry_count: number;
    last_repository_sync_failure?: string;
    last_wiki_sync_failure: string;
    last_repository_verification_failure: string;
    last_wiki_verification_failure: string;
    repository_verification_checksum_sha: string;
    wiki_verification_checksum_sha: string;
    repository_checksum_mismatch: boolean;
    wiki_checksum_mismatch: boolean;
}
interface GeoNodeStatusSchema extends Record<string, unknown> {
    geo_node_id: number;
    healthy: boolean;
    health: string;
    health_status: string;
    missing_oauth_application: boolean;
    attachments_count: number;
    attachments_synced_count?: number;
    attachments_failed_count?: number;
    attachments_synced_missing_on_primary_count: number;
    attachments_synced_in_percentage: string;
    db_replication_lag_seconds?: number;
    lfs_objects_count: number;
    lfs_objects_synced_count?: number;
    lfs_objects_failed_count?: number;
    lfs_objects_synced_missing_on_primary_count: number;
    lfs_objects_synced_in_percentage: string;
    job_artifacts_count: number;
    job_artifacts_synced_count?: number;
    job_artifacts_failed_count?: number;
    job_artifacts_synced_missing_on_primary_count: number;
    job_artifacts_synced_in_percentage: string;
    container_repositories_count: number;
    container_repositories_synced_count?: number;
    container_repositories_failed_count?: number;
    container_repositories_synced_in_percentage: string;
    design_repositories_count: number;
    design_repositories_synced_count?: number;
    design_repositories_failed_count?: number;
    design_repositories_synced_in_percentage: string;
    projects_count: number;
    repositories_count: number;
    repositories_failed_count?: number;
    repositories_synced_count?: number;
    repositories_synced_in_percentage: string;
    wikis_count: number;
    wikis_failed_count?: number;
    wikis_synced_count?: number;
    wikis_synced_in_percentage: string;
    replication_slots_count: number;
    replication_slots_used_count: number;
    replication_slots_used_in_percentage: string;
    replication_slots_max_retained_wal_bytes: number;
    repositories_checked_count: number;
    repositories_checked_failed_count: number;
    repositories_checked_in_percentage: string;
    repositories_checksummed_count: number;
    repositories_checksum_failed_count: number;
    repositories_checksummed_in_percentage: string;
    wikis_checksummed_count: number;
    wikis_checksum_failed_count: number;
    wikis_checksummed_in_percentage: string;
    repositories_verified_count: number;
    repositories_verification_failed_count: number;
    repositories_verified_in_percentage: string;
    repositories_checksum_mismatch_count: number;
    wikis_verified_count: number;
    wikis_verification_failed_count: number;
    wikis_verified_in_percentage: string;
    wikis_checksum_mismatch_count: number;
    repositories_retrying_verification_count: number;
    wikis_retrying_verification_count: number;
    last_event_id: number;
    last_event_timestamp: number;
    cursor_last_event_id?: number;
    cursor_last_event_timestamp: number;
    last_successful_status_check_timestamp: number;
    version: string;
    revision: string;
    package_files_count: number;
    package_files_checksummed_count: number;
    package_files_checksum_failed_count: number;
    package_files_registry_count: number;
    package_files_synced_count: number;
    package_files_failed_count: number;
    snippet_repositories_count: number;
    snippet_repositories_checksummed_count: number;
    snippet_repositories_checksum_failed_count: number;
    snippet_repositories_registry_count: number;
    snippet_repositories_synced_count: number;
    snippet_repositories_failed_count: number;
    group_wiki_repositories_checksummed_count: number;
    group_wiki_repositories_checksum_failed_count: number;
    group_wiki_repositories_registry_count: number;
    group_wiki_repositories_synced_count: number;
    group_wiki_repositories_failed_count: number;
}
declare class GeoNodes<C extends boolean = false> extends BaseService<C> {
    all(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, GeoNodeSchema>[]>;
    create(geonodeId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, GeoNodeSchema>>;
    edit(geonodeId: number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, GeoNodeSchema>>;
    failures(options?: BaseRequestOptions): Promise<CamelizedRecord<C, GeoNodeFailureSchema>[]>;
    repair(geonodeId: number, options?: Sudo): Promise<CamelizedRecord<C, GeoNodeSchema>>;
    remove(geonodeId: number, options?: Sudo): Promise<CamelizedRecord<C, GeoNodeSchema>>;
    show(geonodeId: number, options?: Sudo): Promise<CamelizedRecord<C, GeoNodeSchema>>;
    status(geonodeId: number, options?: Sudo): Promise<CamelizedRecord<C, GeoNodeStatusSchema>>;
    statuses(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, GeoNodeStatusSchema>[]>;
}

declare class GitignoreTemplates<C extends boolean = false> extends ResourceTemplates<C> {
    constructor(options: BaseServiceOptions<C>);
}

declare class GitLabCIYMLTemplates<C extends boolean = false> extends ResourceTemplates<C> {
    constructor(options: BaseServiceOptions<C>);
}

interface KeySchema extends Record<string, unknown> {
    id: number;
    title: string;
    key: string;
    created_at: string;
    expires_at: string;
    user: UserExtendedSchema;
}
declare class Keys<C extends boolean = false> extends BaseService<C> {
    show(keyId: string, options?: Sudo): Promise<CamelizedRecord<C, KeySchema>>;
}

interface LicenseSchema extends Record<string, unknown> {
    id: number;
    plan: string;
    created_at: string;
    starts_at: string;
    expires_at: string;
    historical_max: number;
    maximum_user_count: number;
    expired: boolean;
    overage: number;
    user_limit: number;
    active_users: number;
    licensee: {
        Name: string;
    };
    add_ons: {
        GitLab_FileLocks: number;
        GitLab_Auditor_User: number;
    };
}
declare class License<C extends boolean = false> extends BaseService<C> {
    add(license: string, options?: Sudo): Promise<CamelizedRecord<C, LicenseSchema>>;
    all(options?: Sudo): Promise<CamelizedRecord<C, LicenseSchema>[]>;
    show(options?: Sudo): Promise<CamelizedRecord<C, LicenseSchema>>;
    remove(licenceId: number, options?: Sudo): Promise<CamelizedRecord<C, LicenseSchema>>;
}

interface LintSchema extends Record<string, unknown> {
    status: string;
    errors?: string[];
    warnings?: string[];
}
declare class Lint<C extends boolean = false> extends BaseService<C> {
    lint(content: string, options?: Sudo): Promise<CamelizedRecord<C, LintSchema>>;
}

interface NamespaceSchema extends Record<string, unknown> {
    id: number;
    name: string;
    path: string;
    kind: string;
    full_path: string;
    parent_id?: number;
    avatar_url: string;
    web_url: string;
    billable_members_count: number;
    plan: string;
    trial_ends_on?: string;
    trial: boolean;
}
declare class Namespaces<C extends boolean = false> extends BaseService<C> {
    all(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, NamespaceSchema>[]>;
    show(namespaceId: string | number, options?: {
        search?: string;
    } & Sudo): Promise<CamelizedRecord<C, NamespaceSchema>>;
}

declare type NotificationSettingLevel = 'disabled' | 'participating' | 'watch' | 'global' | 'mention' | 'custom';
interface NotificationSettingSchema extends Record<string, unknown> {
    level: NotificationSettingLevel;
    notification_email: string;
}
declare type ProjectOrGroup = {
    projectId?: string | number;
} | {
    groupId?: string | number;
};
declare class NotificationSettings<C extends boolean = false> extends BaseService<C> {
    all({ projectId, groupId, ...options }?: ProjectOrGroup & PaginatedRequestOptions): Promise<CamelizedRecord<C, NotificationSettingSchema>[]>;
    edit({ projectId, groupId, ...options }?: {
        level?: NotificationSettingLevel;
    } & ProjectOrGroup & BaseRequestOptions): Promise<CamelizedRecord<C, NotificationSettingSchema>>;
}

interface MarkdownSchema extends Record<string, unknown> {
    html: string;
}
declare class Markdown<C extends boolean = false> extends BaseService<C> {
    render(text: string, options?: {
        gfm?: string;
        project?: string | number;
    } & Sudo): Promise<CamelizedRecord<C, MarkdownSchema>>;
}

interface PagesDomainSchema extends Record<string, unknown> {
    domain: string;
    url: string;
    project_id: number;
    auto_ssl_enabled: boolean;
    certificate: {
        expired: boolean;
        expiration: string;
    };
}
declare class PagesDomains<C extends boolean = false> extends BaseService<C> {
    all({ projectId, ...options }?: {
        projectId?: string | number;
    } & PaginatedRequestOptions): Promise<CamelizedRecord<C, PagesDomainSchema>[]>;
    create(projectId: string | number, domain: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PagesDomainSchema>>;
    edit(projectId: string | number, domain: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, PagesDomainSchema>>;
    show(projectId: string | number, domain: string, options?: Sudo): Promise<CamelizedRecord<C, PagesDomainSchema>>;
    remove(projectId: string | number, domain: string, options?: Sudo): Promise<void>;
}

interface SearchResultSchema extends Record<string, unknown> {
    id: number;
    description: string;
    name: string;
    name_with_namespace: string;
    path: string;
    path_with_namespace: string;
    created_at: string;
    default_branch: string;
    tag_list?: string[];
    ssh_url_to_repo: string;
    http_url_to_repo: string;
    web_url: string;
    avatar_url?: string;
    star_count: number;
    forks_count: number;
    last_activity_at: string;
}
declare class Search<C extends boolean = false> extends BaseService<C> {
    all(scope: string, search: string, { projectId, groupId, ...options }?: {
        projectId?: string | number;
        groupId?: string | number;
    } & BaseRequestOptions): Promise<CamelizedRecord<C, SearchResultSchema>[]>;
}

interface ProcessMetricSchema {
    hostname: string;
    pid: number;
    tag: string;
    started_at: string;
    queues?: string[];
    labels?: string[];
    concurrency: number;
    busy: number;
}
interface SidekickProcessMetricsSchema extends Record<string, unknown> {
    processes?: ProcessMetricSchema[];
}
interface SidekickQueueMetricsSchema extends Record<string, unknown> {
    queues: {
        default: {
            backlog: number;
            latency: number;
        };
    };
}
interface SidekickJobStatsSchema extends Record<string, unknown> {
    jobs: {
        processed: number;
        failed: number;
        enqueued: number;
        dead: number;
    };
}
interface SidekickCompoundMetricsSchema extends SidekickJobStatsSchema, SidekickQueueMetricsSchema, SidekickProcessMetricsSchema {
}
declare class SidekiqMetrics<C extends boolean = false> extends BaseService<C> {
    queueMetrics(): Promise<CamelizedRecord<C, SidekickQueueMetricsSchema>>;
    processMetrics(): Promise<CamelizedRecord<C, SidekickProcessMetricsSchema>>;
    jobStats(): Promise<CamelizedRecord<C, SidekickJobStatsSchema>>;
    compoundMetrics(): Promise<CamelizedRecord<C, SidekickCompoundMetricsSchema>>;
}

interface SystemHookSchema extends Record<string, unknown> {
    id: number;
    url: string;
    created_at: string;
    push_events: boolean;
    tag_push_events: boolean;
    merge_requests_events: boolean;
    repository_update_events: boolean;
    enable_ssl_verification: boolean;
}
declare class SystemHooks<C extends boolean = false> extends BaseService<C> {
    add(url: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, SystemHookSchema>>;
    all(options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, SystemHookSchema>[]>;
    edit(hookId: number, url: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, SystemHookSchema>>;
    remove(hookId: number, options?: Sudo): Promise<void>;
}

interface VersionSchema extends Record<string, unknown> {
    version: string;
    revision: string;
}
declare class Version<C extends boolean = false> extends BaseService<C> {
    show(options?: Sudo): Promise<CamelizedRecord<C, VersionSchema>>;
}

interface WikiSchema extends Record<string, unknown> {
    content: string;
    format: string;
    slug: string;
    title: string;
}
declare class Wikis<C extends boolean = false> extends BaseService<C> {
    all(projectId: string | number, options?: PaginatedRequestOptions): Promise<CamelizedRecord<C, WikiSchema>[]>;
    create(projectId: string | number, options?: BaseRequestOptions): Promise<CamelizedRecord<C, WikiSchema>>;
    edit(projectId: string | number, slug: string, options?: BaseRequestOptions): Promise<CamelizedRecord<C, WikiSchema>>;
    show(projectId: string | number, slug: string, options?: Sudo): Promise<CamelizedRecord<C, WikiSchema>>;
    remove(projectId: string | number, slug: string, options?: Sudo): Promise<void>;
}

type APIServices_Groups<_0> = Groups<_0>;
declare const APIServices_Groups: typeof Groups;
type APIServices_GroupAccessRequests<_0> = GroupAccessRequests<_0>;
declare const APIServices_GroupAccessRequests: typeof GroupAccessRequests;
type APIServices_GroupBadges<_0> = GroupBadges<_0>;
declare const APIServices_GroupBadges: typeof GroupBadges;
type APIServices_GroupCustomAttributes<_0> = GroupCustomAttributes<_0>;
declare const APIServices_GroupCustomAttributes: typeof GroupCustomAttributes;
type APIServices_GroupIssueBoards<_0> = GroupIssueBoards<_0>;
declare const APIServices_GroupIssueBoards: typeof GroupIssueBoards;
type APIServices_GroupMembers<_0> = GroupMembers<_0>;
declare const APIServices_GroupMembers: typeof GroupMembers;
type APIServices_GroupMilestones<_0> = GroupMilestones<_0>;
declare const APIServices_GroupMilestones: typeof GroupMilestones;
type APIServices_GroupRunners<_0> = GroupRunners<_0>;
declare const APIServices_GroupRunners: typeof GroupRunners;
type APIServices_GroupVariables<_0> = GroupVariables<_0>;
declare const APIServices_GroupVariables: typeof GroupVariables;
type APIServices_GroupLabels<_0> = GroupLabels<_0>;
declare const APIServices_GroupLabels: typeof GroupLabels;
type APIServices_GroupDeployTokens<_0> = GroupDeployTokens<_0>;
declare const APIServices_GroupDeployTokens: typeof GroupDeployTokens;
type APIServices_Epics<_0> = Epics<_0>;
declare const APIServices_Epics: typeof Epics;
type APIServices_EpicIssues<_0> = EpicIssues<_0>;
declare const APIServices_EpicIssues: typeof EpicIssues;
type APIServices_EpicNotes<_0> = EpicNotes<_0>;
declare const APIServices_EpicNotes: typeof EpicNotes;
type APIServices_EpicDiscussions<_0> = EpicDiscussions<_0>;
declare const APIServices_EpicDiscussions: typeof EpicDiscussions;
type APIServices_Users<_0> = Users<_0>;
declare const APIServices_Users: typeof Users;
type APIServices_UserCustomAttributes<_0> = UserCustomAttributes<_0>;
declare const APIServices_UserCustomAttributes: typeof UserCustomAttributes;
type APIServices_UserEmails<_0> = UserEmails<_0>;
declare const APIServices_UserEmails: typeof UserEmails;
type APIServices_UserImpersonationTokens<_0> = UserImpersonationTokens<_0>;
declare const APIServices_UserImpersonationTokens: typeof UserImpersonationTokens;
type APIServices_UserSSHKeys<_0> = UserSSHKeys<_0>;
declare const APIServices_UserSSHKeys: typeof UserSSHKeys;
type APIServices_UserGPGKeys<_0> = UserGPGKeys<_0>;
declare const APIServices_UserGPGKeys: typeof UserGPGKeys;
type APIServices_Branches<_0> = Branches<_0>;
declare const APIServices_Branches: typeof Branches;
type APIServices_Commits<_0> = Commits<_0>;
declare const APIServices_Commits: typeof Commits;
type APIServices_CommitDiscussions<_0> = CommitDiscussions<_0>;
declare const APIServices_CommitDiscussions: typeof CommitDiscussions;
type APIServices_ContainerRegistry<_0> = ContainerRegistry<_0>;
declare const APIServices_ContainerRegistry: typeof ContainerRegistry;
type APIServices_Deployments<_0> = Deployments<_0>;
declare const APIServices_Deployments: typeof Deployments;
type APIServices_DeployKeys<_0> = DeployKeys<_0>;
declare const APIServices_DeployKeys: typeof DeployKeys;
type APIServices_Environments<_0> = Environments<_0>;
declare const APIServices_Environments: typeof Environments;
type APIServices_FreezePeriods<_0> = FreezePeriods<_0>;
declare const APIServices_FreezePeriods: typeof FreezePeriods;
type APIServices_Issues<_0> = Issues<_0>;
declare const APIServices_Issues: typeof Issues;
type APIServices_IssuesStatistics<_0> = IssuesStatistics<_0>;
declare const APIServices_IssuesStatistics: typeof IssuesStatistics;
type APIServices_IssueNotes<_0> = IssueNotes<_0>;
declare const APIServices_IssueNotes: typeof IssueNotes;
type APIServices_IssueNoteAwardEmojis<_0> = IssueNoteAwardEmojis<_0>;
declare const APIServices_IssueNoteAwardEmojis: typeof IssueNoteAwardEmojis;
type APIServices_IssueDiscussions<_0> = IssueDiscussions<_0>;
declare const APIServices_IssueDiscussions: typeof IssueDiscussions;
type APIServices_IssueAwardEmojis<_0> = IssueAwardEmojis<_0>;
declare const APIServices_IssueAwardEmojis: typeof IssueAwardEmojis;
type APIServices_Jobs<_0> = Jobs<_0>;
declare const APIServices_Jobs: typeof Jobs;
type APIServices_Labels<_0> = Labels<_0>;
declare const APIServices_Labels: typeof Labels;
type APIServices_MergeRequests<_0> = MergeRequests<_0>;
declare const APIServices_MergeRequests: typeof MergeRequests;
type APIServices_MergeRequestApprovals<_0> = MergeRequestApprovals<_0>;
declare const APIServices_MergeRequestApprovals: typeof MergeRequestApprovals;
type APIServices_MergeRequestAwardEmojis<_0> = MergeRequestAwardEmojis<_0>;
declare const APIServices_MergeRequestAwardEmojis: typeof MergeRequestAwardEmojis;
type APIServices_MergeRequestDiscussions<_0> = MergeRequestDiscussions<_0>;
declare const APIServices_MergeRequestDiscussions: typeof MergeRequestDiscussions;
type APIServices_MergeRequestNotes<_0> = MergeRequestNotes<_0>;
declare const APIServices_MergeRequestNotes: typeof MergeRequestNotes;
type APIServices_Packages<_0> = Packages<_0>;
declare const APIServices_Packages: typeof Packages;
type APIServices_Pipelines<_0> = Pipelines<_0>;
declare const APIServices_Pipelines: typeof Pipelines;
type APIServices_PipelineSchedules<_0> = PipelineSchedules<_0>;
declare const APIServices_PipelineSchedules: typeof PipelineSchedules;
type APIServices_PipelineScheduleVariables<_0> = PipelineScheduleVariables<_0>;
declare const APIServices_PipelineScheduleVariables: typeof PipelineScheduleVariables;
type APIServices_Projects<_0> = Projects<_0>;
declare const APIServices_Projects: typeof Projects;
type APIServices_ProjectAccessRequests<_0> = ProjectAccessRequests<_0>;
declare const APIServices_ProjectAccessRequests: typeof ProjectAccessRequests;
type APIServices_ProjectBadges<_0> = ProjectBadges<_0>;
declare const APIServices_ProjectBadges: typeof ProjectBadges;
type APIServices_ProjectCustomAttributes<_0> = ProjectCustomAttributes<_0>;
declare const APIServices_ProjectCustomAttributes: typeof ProjectCustomAttributes;
type APIServices_ProjectImportExport<_0> = ProjectImportExport<_0>;
declare const APIServices_ProjectImportExport: typeof ProjectImportExport;
type APIServices_ProjectIssueBoards<_0> = ProjectIssueBoards<_0>;
declare const APIServices_ProjectIssueBoards: typeof ProjectIssueBoards;
type APIServices_ProjectHooks<_0> = ProjectHooks<_0>;
declare const APIServices_ProjectHooks: typeof ProjectHooks;
type APIServices_ProjectMembers<_0> = ProjectMembers<_0>;
declare const APIServices_ProjectMembers: typeof ProjectMembers;
type APIServices_ProjectMilestones<_0> = ProjectMilestones<_0>;
declare const APIServices_ProjectMilestones: typeof ProjectMilestones;
type APIServices_ProjectSnippets<_0> = ProjectSnippets<_0>;
declare const APIServices_ProjectSnippets: typeof ProjectSnippets;
type APIServices_ProjectSnippetNotes<_0> = ProjectSnippetNotes<_0>;
declare const APIServices_ProjectSnippetNotes: typeof ProjectSnippetNotes;
type APIServices_ProjectSnippetDiscussions<_0> = ProjectSnippetDiscussions<_0>;
declare const APIServices_ProjectSnippetDiscussions: typeof ProjectSnippetDiscussions;
type APIServices_ProjectSnippetAwardEmojis<_0> = ProjectSnippetAwardEmojis<_0>;
declare const APIServices_ProjectSnippetAwardEmojis: typeof ProjectSnippetAwardEmojis;
type APIServices_ProtectedBranches<_0> = ProtectedBranches<_0>;
declare const APIServices_ProtectedBranches: typeof ProtectedBranches;
type APIServices_ProtectedTags<_0> = ProtectedTags<_0>;
declare const APIServices_ProtectedTags: typeof ProtectedTags;
type APIServices_ProjectVariables<_0> = ProjectVariables<_0>;
declare const APIServices_ProjectVariables: typeof ProjectVariables;
type APIServices_ProjectDeployTokens<_0> = ProjectDeployTokens<_0>;
declare const APIServices_ProjectDeployTokens: typeof ProjectDeployTokens;
type APIServices_PushRules<_0> = PushRules<_0>;
declare const APIServices_PushRules: typeof PushRules;
type APIServices_Releases<_0> = Releases<_0>;
declare const APIServices_Releases: typeof Releases;
type APIServices_ReleaseLinks<_0> = ReleaseLinks<_0>;
declare const APIServices_ReleaseLinks: typeof ReleaseLinks;
type APIServices_Repositories<_0> = Repositories<_0>;
declare const APIServices_Repositories: typeof Repositories;
type APIServices_RepositoryFiles<_0> = RepositoryFiles<_0>;
declare const APIServices_RepositoryFiles: typeof RepositoryFiles;
type APIServices_Runners<_0> = Runners<_0>;
declare const APIServices_Runners: typeof Runners;
type APIServices_Services<_0> = Services<_0>;
declare const APIServices_Services: typeof Services;
type APIServices_Tags<_0> = Tags<_0>;
declare const APIServices_Tags: typeof Tags;
type APIServices_Todos<_0> = Todos<_0>;
declare const APIServices_Todos: typeof Todos;
type APIServices_Triggers<_0> = Triggers<_0>;
declare const APIServices_Triggers: typeof Triggers;
type APIServices_VulnerabilityFindings<_0> = VulnerabilityFindings<_0>;
declare const APIServices_VulnerabilityFindings: typeof VulnerabilityFindings;
type APIServices_ApplicationSettings<_0> = ApplicationSettings<_0>;
declare const APIServices_ApplicationSettings: typeof ApplicationSettings;
type APIServices_BroadcastMessages<_0> = BroadcastMessages<_0>;
declare const APIServices_BroadcastMessages: typeof BroadcastMessages;
type APIServices_Events<_0> = Events<_0>;
declare const APIServices_Events: typeof Events;
type APIServices_FeatureFlags<_0> = FeatureFlags<_0>;
declare const APIServices_FeatureFlags: typeof FeatureFlags;
type APIServices_GeoNodes<_0> = GeoNodes<_0>;
declare const APIServices_GeoNodes: typeof GeoNodes;
type APIServices_GitignoreTemplates<_0> = GitignoreTemplates<_0>;
declare const APIServices_GitignoreTemplates: typeof GitignoreTemplates;
type APIServices_GitLabCIYMLTemplates<_0> = GitLabCIYMLTemplates<_0>;
declare const APIServices_GitLabCIYMLTemplates: typeof GitLabCIYMLTemplates;
type APIServices_Keys<_0> = Keys<_0>;
declare const APIServices_Keys: typeof Keys;
type APIServices_License<_0> = License<_0>;
declare const APIServices_License: typeof License;
type APIServices_LicenseTemplates<_0> = LicenseTemplates<_0>;
declare const APIServices_LicenseTemplates: typeof LicenseTemplates;
type APIServices_Lint<_0> = Lint<_0>;
declare const APIServices_Lint: typeof Lint;
type APIServices_Namespaces<_0> = Namespaces<_0>;
declare const APIServices_Namespaces: typeof Namespaces;
type APIServices_NotificationSettings<_0> = NotificationSettings<_0>;
declare const APIServices_NotificationSettings: typeof NotificationSettings;
type APIServices_Markdown<_0> = Markdown<_0>;
declare const APIServices_Markdown: typeof Markdown;
type APIServices_PagesDomains<_0> = PagesDomains<_0>;
declare const APIServices_PagesDomains: typeof PagesDomains;
type APIServices_Search<_0> = Search<_0>;
declare const APIServices_Search: typeof Search;
type APIServices_SidekiqMetrics<_0> = SidekiqMetrics<_0>;
declare const APIServices_SidekiqMetrics: typeof SidekiqMetrics;
type APIServices_Snippets<_0> = Snippets<_0>;
declare const APIServices_Snippets: typeof Snippets;
type APIServices_SystemHooks<_0> = SystemHooks<_0>;
declare const APIServices_SystemHooks: typeof SystemHooks;
type APIServices_Version<_0> = Version<_0>;
declare const APIServices_Version: typeof Version;
type APIServices_Wikis<_0> = Wikis<_0>;
declare const APIServices_Wikis: typeof Wikis;
declare namespace APIServices {
  export {
    APIServices_Groups as Groups,
    APIServices_GroupAccessRequests as GroupAccessRequests,
    APIServices_GroupBadges as GroupBadges,
    APIServices_GroupCustomAttributes as GroupCustomAttributes,
    APIServices_GroupIssueBoards as GroupIssueBoards,
    APIServices_GroupMembers as GroupMembers,
    APIServices_GroupMilestones as GroupMilestones,
    APIServices_GroupRunners as GroupRunners,
    APIServices_GroupVariables as GroupVariables,
    APIServices_GroupLabels as GroupLabels,
    APIServices_GroupDeployTokens as GroupDeployTokens,
    APIServices_Epics as Epics,
    APIServices_EpicIssues as EpicIssues,
    APIServices_EpicNotes as EpicNotes,
    APIServices_EpicDiscussions as EpicDiscussions,
    APIServices_Users as Users,
    APIServices_UserCustomAttributes as UserCustomAttributes,
    APIServices_UserEmails as UserEmails,
    APIServices_UserImpersonationTokens as UserImpersonationTokens,
    APIServices_UserSSHKeys as UserSSHKeys,
    APIServices_UserGPGKeys as UserGPGKeys,
    APIServices_Branches as Branches,
    APIServices_Commits as Commits,
    APIServices_CommitDiscussions as CommitDiscussions,
    APIServices_ContainerRegistry as ContainerRegistry,
    APIServices_Deployments as Deployments,
    APIServices_DeployKeys as DeployKeys,
    APIServices_Environments as Environments,
    APIServices_FreezePeriods as FreezePeriods,
    APIServices_Issues as Issues,
    APIServices_IssuesStatistics as IssuesStatistics,
    APIServices_IssueNotes as IssueNotes,
    APIServices_IssueNoteAwardEmojis as IssueNoteAwardEmojis,
    APIServices_IssueDiscussions as IssueDiscussions,
    APIServices_IssueAwardEmojis as IssueAwardEmojis,
    APIServices_Jobs as Jobs,
    APIServices_Labels as Labels,
    APIServices_MergeRequests as MergeRequests,
    APIServices_MergeRequestApprovals as MergeRequestApprovals,
    APIServices_MergeRequestAwardEmojis as MergeRequestAwardEmojis,
    APIServices_MergeRequestDiscussions as MergeRequestDiscussions,
    APIServices_MergeRequestNotes as MergeRequestNotes,
    APIServices_Packages as Packages,
    APIServices_Pipelines as Pipelines,
    APIServices_PipelineSchedules as PipelineSchedules,
    APIServices_PipelineScheduleVariables as PipelineScheduleVariables,
    APIServices_Projects as Projects,
    APIServices_ProjectAccessRequests as ProjectAccessRequests,
    APIServices_ProjectBadges as ProjectBadges,
    APIServices_ProjectCustomAttributes as ProjectCustomAttributes,
    APIServices_ProjectImportExport as ProjectImportExport,
    APIServices_ProjectIssueBoards as ProjectIssueBoards,
    APIServices_ProjectHooks as ProjectHooks,
    APIServices_ProjectMembers as ProjectMembers,
    APIServices_ProjectMilestones as ProjectMilestones,
    APIServices_ProjectSnippets as ProjectSnippets,
    APIServices_ProjectSnippetNotes as ProjectSnippetNotes,
    APIServices_ProjectSnippetDiscussions as ProjectSnippetDiscussions,
    APIServices_ProjectSnippetAwardEmojis as ProjectSnippetAwardEmojis,
    APIServices_ProtectedBranches as ProtectedBranches,
    APIServices_ProtectedTags as ProtectedTags,
    APIServices_ProjectVariables as ProjectVariables,
    APIServices_ProjectDeployTokens as ProjectDeployTokens,
    APIServices_PushRules as PushRules,
    APIServices_Releases as Releases,
    APIServices_ReleaseLinks as ReleaseLinks,
    APIServices_Repositories as Repositories,
    APIServices_RepositoryFiles as RepositoryFiles,
    APIServices_Runners as Runners,
    APIServices_Services as Services,
    APIServices_Tags as Tags,
    APIServices_Todos as Todos,
    APIServices_Triggers as Triggers,
    APIServices_VulnerabilityFindings as VulnerabilityFindings,
    APIServices_ApplicationSettings as ApplicationSettings,
    APIServices_BroadcastMessages as BroadcastMessages,
    APIServices_Events as Events,
    APIServices_FeatureFlags as FeatureFlags,
    APIServices_GeoNodes as GeoNodes,
    APIServices_GitignoreTemplates as GitignoreTemplates,
    APIServices_GitLabCIYMLTemplates as GitLabCIYMLTemplates,
    APIServices_Keys as Keys,
    APIServices_License as License,
    APIServices_LicenseTemplates as LicenseTemplates,
    APIServices_Lint as Lint,
    APIServices_Namespaces as Namespaces,
    APIServices_NotificationSettings as NotificationSettings,
    APIServices_Markdown as Markdown,
    APIServices_PagesDomains as PagesDomains,
    APIServices_Search as Search,
    APIServices_SidekiqMetrics as SidekiqMetrics,
    APIServices_Snippets as Snippets,
    APIServices_SystemHooks as SystemHooks,
    APIServices_Version as Version,
    APIServices_Wikis as Wikis,
  };
}

declare function getAPIMap(): Record<string, unknown>;

declare const UsersBundle: BundleType<{
    Users: typeof Users;
    UserCustomAttributes: typeof UserCustomAttributes;
    UserEmails: typeof UserEmails;
    UserImpersonationTokens: typeof UserImpersonationTokens;
    UserSSHKeys: typeof UserSSHKeys;
    UserGPGKeys: typeof UserGPGKeys;
}, "Users" | "UserCustomAttributes" | "UserEmails" | "UserImpersonationTokens" | "UserSSHKeys" | "UserGPGKeys">;
declare type UsersBundle = InstanceType<typeof UsersBundle>;
declare const GroupsBundle: BundleType<{
    Groups: typeof Groups;
    GroupAccessRequests: typeof GroupAccessRequests;
    GroupBadges: typeof GroupBadges;
    GroupCustomAttributes: typeof GroupCustomAttributes;
    GroupIssueBoards: typeof GroupIssueBoards;
    GroupMembers: typeof GroupMembers;
    GroupMilestones: typeof GroupMilestones;
    GroupRunners: typeof GroupRunners;
    GroupVariables: typeof GroupVariables;
    GroupLabels: typeof GroupLabels;
    GroupDeployTokens: typeof GroupDeployTokens;
    Epics: typeof Epics;
    EpicIssues: typeof EpicIssues;
    EpicNotes: typeof EpicNotes;
    EpicDiscussions: typeof EpicDiscussions;
}, "Groups" | "GroupAccessRequests" | "GroupBadges" | "GroupCustomAttributes" | "GroupIssueBoards" | "GroupMembers" | "GroupMilestones" | "GroupRunners" | "GroupVariables" | "GroupLabels" | "GroupDeployTokens" | "Epics" | "EpicIssues" | "EpicNotes" | "EpicDiscussions">;
declare type GroupsBundle = InstanceType<typeof GroupsBundle>;
declare const ProjectsBundle: BundleType<{
    Branches: typeof Branches;
    Commits: typeof Commits;
    CommitDiscussions: typeof CommitDiscussions;
    ContainerRegistry: typeof ContainerRegistry;
    DeployKeys: typeof DeployKeys;
    Deployments: typeof Deployments;
    Environments: typeof Environments;
    FreezePeriods: typeof FreezePeriods;
    Issues: typeof Issues;
    IssuesStatistics: typeof IssuesStatistics;
    IssueAwardEmojis: typeof IssueAwardEmojis;
    IssueNotes: typeof IssueNotes;
    IssueNoteAwardEmojis: typeof IssueNoteAwardEmojis;
    IssueDiscussions: typeof IssueDiscussions;
    Jobs: typeof Jobs;
    Labels: typeof Labels;
    MergeRequests: typeof MergeRequests;
    MergeRequestApprovals: typeof MergeRequestApprovals;
    MergeRequestAwardEmojis: typeof MergeRequestAwardEmojis;
    MergeRequestDiscussions: typeof MergeRequestDiscussions;
    MergeRequestNotes: typeof MergeRequestNotes;
    Packages: typeof Packages;
    Pipelines: typeof Pipelines;
    PipelineSchedules: typeof PipelineSchedules;
    PipelineScheduleVariables: typeof PipelineScheduleVariables;
    Projects: typeof Projects;
    ProjectAccessRequests: typeof ProjectAccessRequests;
    ProjectBadges: typeof ProjectBadges;
    ProjectCustomAttributes: typeof ProjectCustomAttributes;
    ProjectImportExport: typeof ProjectImportExport;
    ProjectIssueBoards: typeof ProjectIssueBoards;
    ProjectHooks: typeof ProjectHooks;
    ProjectMembers: typeof ProjectMembers;
    ProjectMilestones: typeof ProjectMilestones;
    ProjectSnippets: typeof ProjectSnippets;
    ProjectSnippetNotes: typeof ProjectSnippetNotes;
    ProjectSnippetDiscussions: typeof ProjectSnippetDiscussions;
    ProjectSnippetAwardEmojis: typeof ProjectSnippetAwardEmojis;
    ProtectedBranches: typeof ProtectedBranches;
    ProtectedTags: typeof ProtectedTags;
    ProjectVariables: typeof ProjectVariables;
    ProjectDeployTokens: typeof ProjectDeployTokens;
    PushRules: typeof PushRules;
    Releases: typeof Releases;
    ReleaseLinks: typeof ReleaseLinks;
    Repositories: typeof Repositories;
    RepositoryFiles: typeof RepositoryFiles;
    Runners: typeof Runners;
    Services: typeof Services;
    Tags: typeof Tags;
    Todos: typeof Todos;
    Triggers: typeof Triggers;
    VulnerabilityFindings: typeof VulnerabilityFindings;
}, "Branches" | "Commits" | "CommitDiscussions" | "ContainerRegistry" | "DeployKeys" | "Deployments" | "Environments" | "FreezePeriods" | "Issues" | "IssuesStatistics" | "IssueAwardEmojis" | "IssueNotes" | "IssueNoteAwardEmojis" | "IssueDiscussions" | "Jobs" | "Labels" | "MergeRequests" | "MergeRequestApprovals" | "MergeRequestAwardEmojis" | "MergeRequestDiscussions" | "MergeRequestNotes" | "Packages" | "Pipelines" | "PipelineSchedules" | "PipelineScheduleVariables" | "Projects" | "ProjectAccessRequests" | "ProjectBadges" | "ProjectCustomAttributes" | "ProjectImportExport" | "ProjectIssueBoards" | "ProjectHooks" | "ProjectMembers" | "ProjectMilestones" | "ProjectSnippets" | "ProjectSnippetNotes" | "ProjectSnippetDiscussions" | "ProjectSnippetAwardEmojis" | "ProtectedBranches" | "ProtectedTags" | "ProjectVariables" | "ProjectDeployTokens" | "PushRules" | "Releases" | "ReleaseLinks" | "Repositories" | "RepositoryFiles" | "Runners" | "Services" | "Tags" | "Todos" | "Triggers" | "VulnerabilityFindings">;
declare type ProjectsBundle = InstanceType<typeof ProjectsBundle>;
declare const Gitlab: BundleType<typeof APIServices, "Groups" | "GroupAccessRequests" | "GroupBadges" | "GroupCustomAttributes" | "GroupIssueBoards" | "GroupMembers" | "GroupMilestones" | "GroupRunners" | "GroupVariables" | "GroupLabels" | "GroupDeployTokens" | "Epics" | "EpicIssues" | "EpicNotes" | "EpicDiscussions" | "Users" | "UserCustomAttributes" | "UserEmails" | "UserImpersonationTokens" | "UserSSHKeys" | "UserGPGKeys" | "Branches" | "Commits" | "CommitDiscussions" | "ContainerRegistry" | "DeployKeys" | "Deployments" | "Environments" | "FreezePeriods" | "Issues" | "IssuesStatistics" | "IssueAwardEmojis" | "IssueNotes" | "IssueNoteAwardEmojis" | "IssueDiscussions" | "Jobs" | "Labels" | "MergeRequests" | "MergeRequestApprovals" | "MergeRequestAwardEmojis" | "MergeRequestDiscussions" | "MergeRequestNotes" | "Packages" | "Pipelines" | "PipelineSchedules" | "PipelineScheduleVariables" | "Projects" | "ProjectAccessRequests" | "ProjectBadges" | "ProjectCustomAttributes" | "ProjectImportExport" | "ProjectIssueBoards" | "ProjectHooks" | "ProjectMembers" | "ProjectMilestones" | "ProjectSnippets" | "ProjectSnippetNotes" | "ProjectSnippetDiscussions" | "ProjectSnippetAwardEmojis" | "ProtectedBranches" | "ProtectedTags" | "ProjectVariables" | "ProjectDeployTokens" | "PushRules" | "Releases" | "ReleaseLinks" | "Repositories" | "RepositoryFiles" | "Runners" | "Services" | "Tags" | "Todos" | "Triggers" | "VulnerabilityFindings" | "ApplicationSettings" | "BroadcastMessages" | "Events" | "FeatureFlags" | "GeoNodes" | "GitignoreTemplates" | "GitLabCIYMLTemplates" | "Keys" | "License" | "LicenseTemplates" | "Lint" | "Namespaces" | "NotificationSettings" | "Markdown" | "PagesDomains" | "Search" | "SidekiqMetrics" | "Snippets" | "SystemHooks" | "Version" | "Wikis">;
declare type Gitlab = InstanceType<typeof Gitlab>;

export { ApplicationSettings, Branches, BroadcastMessages, CommitDiscussions, Commits, ContainerRegistry, DeployKeys, Deployments, Environments, EpicDiscussions, EpicIssues, EpicNotes, Epics, Events, FeatureFlags, FreezePeriods, GeoNodes, GitLabCIYMLTemplates, GitignoreTemplates, Gitlab, GroupAccessRequests, GroupBadges, GroupCustomAttributes, GroupDeployTokens, GroupIssueBoards, GroupLabels, GroupMembers, GroupMilestones, GroupRunners, GroupVariables, Groups, GroupsBundle, IssueAwardEmojis, IssueDiscussions, IssueNoteAwardEmojis, IssueNotes, Issues, IssuesStatistics, Jobs, Keys, Labels, License, LicenseTemplates, Lint, Markdown, MergeRequestApprovals, MergeRequestAwardEmojis, MergeRequestDiscussions, MergeRequestNotes, MergeRequests, Namespaces, NotificationSettings, Packages, PagesDomains, PipelineScheduleVariables, PipelineSchedules, Pipelines, ProjectAccessRequests, ProjectBadges, ProjectCustomAttributes, ProjectDeployTokens, ProjectHooks, ProjectImportExport, ProjectIssueBoards, ProjectMembers, ProjectMilestones, ProjectSnippetAwardEmojis, ProjectSnippetDiscussions, ProjectSnippetNotes, ProjectSnippets, ProjectVariables, Projects, ProjectsBundle, ProtectedBranches, ProtectedTags, PushRules, ReleaseLinks, Releases, Repositories, RepositoryFiles, Runners, Search, Services, SidekiqMetrics, Snippets, SystemHooks, Tags, Todos, Triggers, UserCustomAttributes, UserEmails, UserGPGKeys, UserImpersonationTokens, UserSSHKeys, Users, UsersBundle, Version, VulnerabilityFindings, Wikis, getAPIMap };
