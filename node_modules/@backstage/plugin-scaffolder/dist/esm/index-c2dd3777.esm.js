import { createApiRef, useApi, Progress, attachComponentData, createExternalRouteRef, createRouteRef, createPlugin, createApiFactory, discoveryApiRef, identityApiRef, createRoutableExtension } from '@backstage/core';
import { ResponseError } from '@backstage/errors';
import ObservableImpl from 'zen-observable';
import { catalogApiRef, formatEntityRefTitle } from '@backstage/plugin-catalog-react';
import { TextField } from '@material-ui/core';
import FormControl from '@material-ui/core/FormControl';
import Autocomplete from '@material-ui/lab/Autocomplete';
import React, { useCallback, useEffect } from 'react';
import { useAsync } from 'react-use';
import Select from '@material-ui/core/Select';
import InputLabel from '@material-ui/core/InputLabel';
import Input from '@material-ui/core/Input';
import FormHelperText from '@material-ui/core/FormHelperText';
import { scmIntegrationsApiRef } from '@backstage/integration-react';

const scaffolderApiRef = createApiRef({
  id: "plugin.scaffolder.service",
  description: "Used to make requests towards the scaffolder backend"
});
class ScaffolderClient {
  constructor(options) {
    this.discoveryApi = options.discoveryApi;
    this.identityApi = options.identityApi;
    this.scmIntegrationsApi = options.scmIntegrationsApi;
  }
  async getIntegrationsList(options) {
    return [
      ...this.scmIntegrationsApi.azure.list(),
      ...this.scmIntegrationsApi.bitbucket.list(),
      ...this.scmIntegrationsApi.github.list(),
      ...this.scmIntegrationsApi.gitlab.list()
    ].map((c) => ({type: c.type, title: c.title, host: c.config.host})).filter((c) => options.allowedHosts.includes(c.host));
  }
  async getTemplateParameterSchema(templateName) {
    const {namespace, kind, name} = templateName;
    const token = await this.identityApi.getIdToken();
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const templatePath = [namespace, kind, name].map((s) => encodeURIComponent(s)).join("/");
    const url = `${baseUrl}/v2/templates/${templatePath}/parameter-schema`;
    const response = await fetch(url, {
      headers: {
        ...token && {Authorization: `Bearer ${token}`}
      }
    });
    if (!response.ok) {
      throw ResponseError.fromResponse(response);
    }
    const schema = await response.json();
    return schema;
  }
  async scaffold(templateName, values) {
    const token = await this.identityApi.getIdToken();
    const url = `${await this.discoveryApi.getBaseUrl("scaffolder")}/v2/tasks`;
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...token && {Authorization: `Bearer ${token}`}
      },
      body: JSON.stringify({templateName, values: {...values}})
    });
    if (response.status !== 201) {
      const status = `${response.status} ${response.statusText}`;
      const body = await response.text();
      throw new Error(`Backend request failed, ${status} ${body.trim()}`);
    }
    const {id} = await response.json();
    return id;
  }
  async getTask(taskId) {
    const token = await this.identityApi.getIdToken();
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}`;
    const response = await fetch(url, {
      headers: token ? {Authorization: `Bearer ${token}`} : {}
    });
    if (!response.ok) {
      throw ResponseError.fromResponse(response);
    }
    return await response.json();
  }
  streamLogs({
    taskId,
    after
  }) {
    return new ObservableImpl((subscriber) => {
      const params = new URLSearchParams();
      if (after !== void 0) {
        params.set("after", String(Number(after)));
      }
      this.discoveryApi.getBaseUrl("scaffolder").then((baseUrl) => {
        const url = `${baseUrl}/v2/tasks/${encodeURIComponent(taskId)}/eventstream`;
        const eventSource = new EventSource(url, {withCredentials: true});
        eventSource.addEventListener("log", (event) => {
          if (event.data) {
            try {
              subscriber.next(JSON.parse(event.data));
            } catch (ex) {
              subscriber.error(ex);
            }
          }
        });
        eventSource.addEventListener("completion", (event) => {
          if (event.data) {
            try {
              subscriber.next(JSON.parse(event.data));
            } catch (ex) {
              subscriber.error(ex);
            }
          }
          eventSource.close();
          subscriber.complete();
        });
        eventSource.addEventListener("error", (event) => {
          subscriber.error(event);
        });
      }, (error) => {
        subscriber.error(error);
      });
    });
  }
  async listActions() {
    const baseUrl = await this.discoveryApi.getBaseUrl("scaffolder");
    const response = await fetch(`${baseUrl}/v2/actions`);
    if (!response.ok) {
      throw ResponseError.fromResponse(response);
    }
    return await response.json();
  }
}

const EntityPicker = ({
  onChange,
  schema: {title = "Entity", description = "An entity from the catalog"},
  required,
  uiSchema,
  rawErrors,
  formData
}) => {
  var _a, _b;
  const allowedKinds = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.allowedKinds;
  const defaultKind = (_b = uiSchema["ui:options"]) == null ? void 0 : _b.defaultKind;
  const catalogApi = useApi(catalogApiRef);
  const {value: entities, loading} = useAsync(() => catalogApi.getEntities(allowedKinds ? {filter: {kind: allowedKinds}} : void 0));
  const entityRefs = entities == null ? void 0 : entities.items.map((e) => formatEntityRefTitle(e, {defaultKind}));
  const onSelect = (_, value) => {
    onChange(value || "");
  };
  return /* @__PURE__ */ React.createElement(FormControl, {
    margin: "normal",
    required,
    error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !formData
  }, /* @__PURE__ */ React.createElement(Autocomplete, {
    value: formData || "",
    loading,
    onChange: onSelect,
    options: entityRefs || [],
    autoSelect: true,
    freeSolo: true,
    renderInput: (params) => /* @__PURE__ */ React.createElement(TextField, {
      ...params,
      label: title,
      margin: "normal",
      helperText: description,
      variant: "outlined",
      required,
      InputProps: params.InputProps
    })
  }));
};

const OwnerPicker = ({
  schema: {title = "Owner", description = "The owner of the component"},
  uiSchema,
  ...props
}) => {
  var _a;
  const ownerUiSchema = {
    ...uiSchema,
    "ui:options": {
      allowedKinds: ((_a = uiSchema["ui:options"]) == null ? void 0 : _a.allowedKinds) || [
        "Group",
        "User"
      ],
      defaultKind: "Group"
    }
  };
  return /* @__PURE__ */ React.createElement(EntityPicker, {
    ...props,
    schema: {title, description},
    uiSchema: ownerUiSchema
  });
};

function splitFormData(url) {
  let host = void 0;
  let owner = void 0;
  let repo = void 0;
  let organization = void 0;
  try {
    if (url) {
      const parsed = new URL(`https://${url}`);
      host = parsed.host;
      owner = parsed.searchParams.get("owner") || void 0;
      repo = parsed.searchParams.get("repo") || void 0;
      organization = parsed.searchParams.get("organization") || void 0;
    }
  } catch {
  }
  return {host, owner, repo, organization};
}
function serializeFormData(data) {
  if (!data.host) {
    return void 0;
  }
  const params = new URLSearchParams();
  if (data.owner) {
    params.set("owner", data.owner);
  }
  if (data.repo) {
    params.set("repo", data.repo);
  }
  if (data.organization) {
    params.set("organization", data.organization);
  }
  return `${data.host}?${params.toString()}`;
}
const RepoUrlPicker = ({
  onChange,
  uiSchema,
  rawErrors,
  formData
}) => {
  var _a;
  const api = useApi(scaffolderApiRef);
  const allowedHosts = (_a = uiSchema["ui:options"]) == null ? void 0 : _a.allowedHosts;
  const {value: integrations, loading} = useAsync(async () => {
    return await api.getIntegrationsList({allowedHosts});
  });
  const {host, owner, repo, organization} = splitFormData(formData);
  const updateHost = useCallback((evt) => onChange(serializeFormData({
    host: evt.target.value,
    owner,
    repo,
    organization
  })), [onChange, owner, repo, organization]);
  const updateOwner = useCallback((evt) => onChange(serializeFormData({
    host,
    owner: evt.target.value,
    repo,
    organization
  })), [onChange, host, repo, organization]);
  const updateRepo = useCallback((evt) => onChange(serializeFormData({
    host,
    owner,
    repo: evt.target.value,
    organization
  })), [onChange, host, owner, organization]);
  const updateOrganization = useCallback((evt) => onChange(serializeFormData({
    host,
    owner,
    repo,
    organization: evt.target.value
  })), [onChange, host, owner, repo]);
  useEffect(() => {
    if (host === void 0 && (integrations == null ? void 0 : integrations.length)) {
      onChange(serializeFormData({
        host: integrations[0].host,
        owner,
        repo,
        organization
      }));
    }
  }, [onChange, integrations, host, owner, repo, organization]);
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(FormControl, {
    margin: "normal",
    required: true,
    error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !host
  }, /* @__PURE__ */ React.createElement(InputLabel, {
    htmlFor: "hostInput"
  }, "Host"), /* @__PURE__ */ React.createElement(Select, {
    native: true,
    id: "hostInput",
    onChange: updateHost,
    value: host
  }, integrations ? integrations.filter((i) => allowedHosts == null ? void 0 : allowedHosts.includes(i.host)).map((i) => /* @__PURE__ */ React.createElement("option", {
    key: i.host,
    value: i.host
  }, i.title)) : /* @__PURE__ */ React.createElement("p", null, "loading")), /* @__PURE__ */ React.createElement(FormHelperText, null, "The host where the repository will be created")), host === "dev.azure.com" && /* @__PURE__ */ React.createElement(FormControl, {
    margin: "normal",
    required: true,
    error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !organization
  }, /* @__PURE__ */ React.createElement(InputLabel, {
    htmlFor: "repoInput"
  }, "Organization"), /* @__PURE__ */ React.createElement(Input, {
    id: "repoInput",
    onChange: updateOrganization,
    value: organization
  }), /* @__PURE__ */ React.createElement(FormHelperText, null, "The name of the organization")), /* @__PURE__ */ React.createElement(FormControl, {
    margin: "normal",
    required: true,
    error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !owner
  }, /* @__PURE__ */ React.createElement(InputLabel, {
    htmlFor: "ownerInput"
  }, "Owner"), /* @__PURE__ */ React.createElement(Input, {
    id: "ownerInput",
    onChange: updateOwner,
    value: owner
  }), /* @__PURE__ */ React.createElement(FormHelperText, null, "The organization, user or project that this repo will belong to")), /* @__PURE__ */ React.createElement(FormControl, {
    margin: "normal",
    required: true,
    error: (rawErrors == null ? void 0 : rawErrors.length) > 0 && !repo
  }, /* @__PURE__ */ React.createElement(InputLabel, {
    htmlFor: "repoInput"
  }, "Repository"), /* @__PURE__ */ React.createElement(Input, {
    id: "repoInput",
    onChange: updateRepo,
    value: repo
  }), /* @__PURE__ */ React.createElement(FormHelperText, null, "The name of the repository")));
};

const repoPickerValidation = (value, validation) => {
  try {
    const {host, searchParams} = new URL(`https://${value}`);
    if (!host || !searchParams.get("owner") || !searchParams.get("repo")) {
      validation.addError("Incomplete repository location provided");
    }
  } catch {
    validation.addError("Unable to parse the Repository URL");
  }
};

const FIELD_EXTENSION_WRAPPER_KEY = "scaffolder.extensions.wrapper.v1";
const FIELD_EXTENSION_KEY = "scaffolder.extensions.field.v1";
function createScaffolderFieldExtension(options) {
  return {
    expose() {
      const FieldExtensionDataHolder = () => null;
      attachComponentData(FieldExtensionDataHolder, FIELD_EXTENSION_KEY, options);
      return FieldExtensionDataHolder;
    }
  };
}
const ScaffolderFieldExtensions = () => null;
attachComponentData(ScaffolderFieldExtensions, FIELD_EXTENSION_WRAPPER_KEY, true);

const registerComponentRouteRef = createExternalRouteRef({
  id: "register-component",
  optional: true
});
const rootRouteRef = createRouteRef({
  title: "Create new entity"
});

const scaffolderPlugin = createPlugin({
  id: "scaffolder",
  apis: [
    createApiFactory({
      api: scaffolderApiRef,
      deps: {
        discoveryApi: discoveryApiRef,
        identityApi: identityApiRef,
        scmIntegrationsApi: scmIntegrationsApiRef
      },
      factory: ({discoveryApi, identityApi, scmIntegrationsApi}) => new ScaffolderClient({discoveryApi, identityApi, scmIntegrationsApi})
    })
  ],
  routes: {
    root: rootRouteRef
  },
  externalRoutes: {
    registerComponent: registerComponentRouteRef
  }
});
const EntityPickerFieldExtension = scaffolderPlugin.provide(createScaffolderFieldExtension({
  component: EntityPicker,
  name: "EntityPicker"
}));
const RepoUrlPickerFieldExtension = scaffolderPlugin.provide(createScaffolderFieldExtension({
  component: RepoUrlPicker,
  name: "RepoUrlPicker",
  validation: repoPickerValidation
}));
const OwnerPickerFieldExtension = scaffolderPlugin.provide(createScaffolderFieldExtension({
  component: OwnerPicker,
  name: "OwnerPicker"
}));
const ScaffolderPage = scaffolderPlugin.provide(createRoutableExtension({
  component: () => import('./Router-f3e2f864.esm.js').then((m) => m.Router),
  mountPoint: rootRouteRef
}));

export { EntityPicker as E, FIELD_EXTENSION_KEY as F, OwnerPicker as O, RepoUrlPicker as R, ScaffolderClient as S, rootRouteRef as a, registerComponentRouteRef as b, FIELD_EXTENSION_WRAPPER_KEY as c, createScaffolderFieldExtension as d, ScaffolderFieldExtensions as e, EntityPickerFieldExtension as f, OwnerPickerFieldExtension as g, RepoUrlPickerFieldExtension as h, ScaffolderPage as i, scaffolderPlugin as j, repoPickerValidation as r, scaffolderApiRef as s };
//# sourceMappingURL=index-c2dd3777.esm.js.map
